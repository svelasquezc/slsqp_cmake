var tipuesearch = {"pages":[{"text":"slsqp Brief description This is a modern object-oriented Fortran implementation of the SLSQP Optimization Method.  It can be used to solve nonlinear programming problems that seek to minimize a scalar performance index subject to nonlinear equality and inequality constraints as well as bounds on the variables. Developer Info Jacob Williams","tags":"","loc":"index.html","title":" slsqp "},{"text":"Files Dependent On This One sourcefile~~slsqp_kinds.f90~~AfferentGraph sourcefile~slsqp_kinds.f90 slsqp_kinds.f90 sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_module.f90 sourcefile~slsqp_test.f90 slsqp_test.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_test.f90 sourcefile~slsqp_test_2.f90 slsqp_test_2.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_test_2.f90 sourcefile~slsqp_support.f90 slsqp_support.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_test.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_test_2.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_module.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules slsqp_kinds Source Code slsqp_kinds.f90 Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 12/22/2015 !  license: BSD ! !  Numeric kind definitions. module slsqp_kinds use , intrinsic :: iso_fortran_env , only : real64 implicit none private integer , parameter , public :: wp = real64 !! Using \"double precision\" real kinds end module slsqp_kinds !*****************************************************************************************","tags":"","loc":"sourcefile/slsqp_kinds.f90.html","title":"slsqp_kinds.f90 – slsqp"},{"text":"This File Depends On sourcefile~~slsqp_support.f90~~EfferentGraph sourcefile~slsqp_support.f90 slsqp_support.f90 sourcefile~slsqp_kinds.f90 slsqp_kinds.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_support.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~slsqp_support.f90~~AfferentGraph sourcefile~slsqp_support.f90 slsqp_support.f90 sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_module.f90 sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_test_2.f90 slsqp_test_2.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_test_2.f90 sourcefile~slsqp_test.f90 slsqp_test.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_test.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules slsqp_support Source Code slsqp_support.f90 Source Code !******************************************************************************* !> license: BSD ! !  Support routines for SLSQP. For example, routines from !  [BLAS](http://www.netlib.org/blas/) and [LINPACK](http://www.netlib.org/linpack/). !  These have also been refactored into modern Fortran. module slsqp_support use slsqp_kinds implicit none private real ( wp ), parameter , public :: epmach = epsilon ( 1.0_wp ) real ( wp ), parameter , public :: zero = 0.0_wp real ( wp ), parameter , public :: one = 1.0_wp real ( wp ), parameter , public :: two = 2.0_wp real ( wp ), parameter , public :: four = 4.0_wp real ( wp ), parameter , public :: ten = 1 0.0_wp real ( wp ), parameter , public :: hun = 10 0.0_wp public :: daxpy , dcopy , ddot , dnrm2 , dscal contains !******************************************************************************* !******************************************************************************* !> !  constant times a vector plus a vector. !  uses unrolled loops for increments equal to one. ! !### Author !  jack dongarra, linpack, 3/11/78. subroutine daxpy ( n , da , dx , incx , dy , incy ) implicit none real ( wp ) :: dx ( * ) , dy ( * ) , da integer :: i , incx , incy , ix , iy , m , mp1 , n if ( n <= 0 ) return if ( da == zero ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 4 ) if ( m /= 0 ) then do i = 1 , m dy ( i ) = dy ( i ) + da * dx ( i ) end do if ( n < 4 ) return end if mp1 = m + 1 do i = mp1 , n , 4 dy ( i ) = dy ( i ) + da * dx ( i ) dy ( i + 1 ) = dy ( i + 1 ) + da * dx ( i + 1 ) dy ( i + 2 ) = dy ( i + 2 ) + da * dx ( i + 2 ) dy ( i + 3 ) = dy ( i + 3 ) + da * dx ( i + 3 ) end do else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dy ( iy ) + da * dx ( ix ) ix = ix + incx iy = iy + incy end do end if end subroutine daxpy !******************************************************************************* !******************************************************************************* !> !  copies a vector, x, to a vector, y. !  uses unrolled loops for increments equal to one. ! !### Author !  jack dongarra, linpack, 3/11/78. subroutine dcopy ( n , dx , incx , dy , incy ) implicit none real ( wp ) :: dx ( * ) , dy ( * ) integer :: i , incx , incy , ix , iy , m , mp1 , n if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 7 ) if ( m /= 0 ) then do i = 1 , m dy ( i ) = dx ( i ) end do if ( n < 7 ) return end if mp1 = m + 1 do i = mp1 , n , 7 dy ( i ) = dx ( i ) dy ( i + 1 ) = dx ( i + 1 ) dy ( i + 2 ) = dx ( i + 2 ) dy ( i + 3 ) = dx ( i + 3 ) dy ( i + 4 ) = dx ( i + 4 ) dy ( i + 5 ) = dx ( i + 5 ) dy ( i + 6 ) = dx ( i + 6 ) end do else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dx ( ix ) ix = ix + incx iy = iy + incy end do end if end subroutine dcopy !******************************************************************************* !******************************************************************************* !> !  forms the dot product of two vectors. !  uses unrolled loops for increments equal to one. ! !### Author !  jack dongarra, linpack, 3/11/78. real ( wp ) function ddot ( n , dx , incx , dy , incy ) implicit none real ( wp ) :: dx ( * ) , dy ( * ) , dtemp integer :: i , incx , incy , ix , iy , m , mp1 , n ddot = zero dtemp = zero if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dtemp = dtemp + dx ( i ) * dy ( i ) end do if ( n < 5 ) then ddot = dtemp return end if end if mp1 = m + 1 do i = mp1 , n , 5 dtemp = dtemp + dx ( i ) * dy ( i ) + dx ( i + 1 ) * dy ( i + 1 ) + & dx ( i + 2 ) * dy ( i + 2 ) + dx ( i + 3 ) * dy ( i + 3 ) + dx ( i + 4 ) * dy ( i + 4 ) end do ddot = dtemp else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dtemp = dtemp + dx ( ix ) * dy ( iy ) ix = ix + incx iy = iy + incy end do ddot = dtemp end if end function ddot !******************************************************************************* !******************************************************************************* !> !  Function that returns the Euclidean norm !   \\sqrt{ \\mathbf{x}&#94;T \\mathbf{x} }  of a vector  \\mathbf{x} . ! !### Further details ! !  * this version written on 25-october-1982. !  * modified on 14-october-1993 to inline the call to dlassq. !    sven hammarling, nag ltd. !  * Converted to modern Fortran, Jacob Williams, Jan. 2016. ! !@note Replaced original SLSQP routine with this one from !      [BLAS](http://netlib.sandia.gov/blas/dnrm2.f). real ( wp ) function dnrm2 ( n , x , incx ) implicit none integer , intent ( in ) :: incx integer , intent ( in ) :: n real ( wp ), dimension ( * ), intent ( in ) :: x real ( wp ) :: absxi , norm , scale , ssq integer :: ix if ( n < 1 . or . incx < 1 ) then norm = zero elseif ( n == 1 ) then norm = abs ( x ( 1 )) else scale = zero ssq = one ! the following loop is equivalent to this call to the lapack ! auxiliary routine: ! call dlassq( n, x, incx, scale, ssq ) do ix = 1 , 1 + ( n - 1 ) * incx , incx if ( x ( ix ) /= zero ) then absxi = abs ( x ( ix )) if ( scale < absxi ) then ssq = one + ssq * ( scale / absxi ) ** 2 scale = absxi else ssq = ssq + ( absxi / scale ) ** 2 end if end if end do norm = scale * sqrt ( ssq ) end if dnrm2 = norm end function dnrm2 !******************************************************************************* !******************************************************************************* !> !  scales a vector by a constant. !  uses unrolled loops for increment equal to one. ! !### Author !  jack dongarra, linpack, 3/11/78. subroutine dscal ( n , da , dx , incx ) implicit none real ( wp ) :: da , dx ( * ) integer :: i , incx , m , mp1 , n , nincx if ( n <= 0 . or . incx <= 0 ) return if ( incx == 1 ) then ! code for increment equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dx ( i ) = da * dx ( i ) end do if ( n < 5 ) return end if mp1 = m + 1 do i = mp1 , n , 5 dx ( i ) = da * dx ( i ) dx ( i + 1 ) = da * dx ( i + 1 ) dx ( i + 2 ) = da * dx ( i + 2 ) dx ( i + 3 ) = da * dx ( i + 3 ) dx ( i + 4 ) = da * dx ( i + 4 ) end do else ! code for increment not equal to 1 nincx = n * incx do i = 1 , nincx , incx dx ( i ) = da * dx ( i ) end do end if end subroutine dscal !******************************************************************************* !******************************************************************************* end module slsqp_support !*******************************************************************************","tags":"","loc":"sourcefile/slsqp_support.f90.html","title":"slsqp_support.f90 – slsqp"},{"text":"This File Depends On sourcefile~~slsqp_module.f90~~EfferentGraph sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_kinds.f90 slsqp_kinds.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_module.f90 sourcefile~slsqp_support.f90 slsqp_support.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_module.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~slsqp_module.f90~~AfferentGraph sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_test_2.f90 slsqp_test_2.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_test_2.f90 sourcefile~slsqp_test.f90 slsqp_test.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_test.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules slsqp_module Source Code slsqp_module.f90 Source Code !******************************************************************************* !> author: Jacob Williams !  license: BSD ! !  Module containing the object-oriented interface to the SLSQP method. !  It is called using the [[slsqp_solver]] class, which !  is the only public entity in this module. module slsqp_module use slsqp_kinds use slsqp_support use slsqp_core use iso_fortran_env , only : error_unit , output_unit implicit none private type , public :: slsqp_solver !! The main class used to interface with the SLSQP solver. private integer :: n = 0 !! number of optimization variables ( n > 0 ) integer :: m = 0 !! number of constraints ( m \\ge 0 ) integer :: meq = 0 !! number of equality constraints ( m \\ge m_{eq} \\ge 0 ) integer :: max_iter = 0 !! maximum number of iterations real ( wp ) :: acc = zero !! accuracy tolerance !these two were not in the original code: real ( wp ) :: alphamin = 0.1_wp !! min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ) :: alphamax = 1.0_wp !! max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  integer :: iprint = output_unit !! unit number of status printing (0 for no printing) real ( wp ), dimension (:), allocatable :: xl !! lower bound on x real ( wp ), dimension (:), allocatable :: xu !! upper bound on x integer :: l_w = 0 !! size of `w` real ( wp ), dimension (:), allocatable :: w !! real work array integer :: l_jw = 0 !! size of `jw` integer , dimension (:), allocatable :: jw !! integer work array procedure ( func ), pointer :: f => null () !! problem function subroutine procedure ( grad ), pointer :: g => null () !! gradient subroutine procedure ( iterfunc ), pointer :: report => null () !! for reporting an iteration integer :: linesearch_mode = 1 !! linesearch mode: !! !! * `1` = inexact (Armijo) linesearch, !! * `2` = exact linesearch. type ( linmin_data ) :: linmin !! data formerly within [[linmin]]. !! Only used when `linesearch_mode=2` type ( slsqpb_data ) :: slsqpb !! data formerly within [[slsqpb]]. logical :: user_triggered_stop = . false . !! if the `abort` method has been called !! to stop the iterations contains private procedure , public :: initialize => initialize_slsqp procedure , public :: destroy => destroy_slsqp procedure , public :: optimize => slsqp_wrapper procedure , public :: abort => stop_iterations procedure :: report_message !! for reporting messages to the user end type slsqp_solver abstract interface subroutine func ( me , x , f , c ) !! for computing the function import :: wp , slsqp_solver implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( out ) :: f !! value of the objective function real ( wp ), dimension (:), intent ( out ) :: c !! the constraint vector `dimension(m)`, !! equality constraints (if any) first. end subroutine func subroutine grad ( me , x , g , a ) !! for computing the gradients import :: wp , slsqp_solver implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( out ) :: g !! objective function partials w.r.t x `dimension(n)` real ( wp ), dimension (:,:), intent ( out ) :: a !! gradient matrix of constraints w.r.t. x `dimension(m,n)` end subroutine grad subroutine iterfunc ( me , iter , x , f , c ) !! for reporting an iteration import :: wp , slsqp_solver implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: iter !! iteration number real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( in ) :: f !! value of the objective function real ( wp ), dimension (:), intent ( in ) :: c !! the constraint vector `dimension(m)`, !! equality constraints (if any) first. end subroutine iterfunc end interface contains !******************************************************************************* !******************************************************************************* !> !  A method that the user can call to stop the iterations. !  (it can be called in any of the functions). !  SLSQP will stop at the end of the next iteration. subroutine stop_iterations ( me ) implicit none class ( slsqp_solver ), intent ( inout ) :: me me % user_triggered_stop = . true . end subroutine stop_iterations !******************************************************************************* !******************************************************************************* !> !  initialize the [[slsqp_solver]] class.  see [[slsqp]] for more details. subroutine initialize_slsqp ( me , n , m , meq , max_iter , acc , f , g , xl , xu , status_ok ,& linesearch_mode , iprint , report , alphamin , alphamax ) implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: n !! the number of varibles,  n \\ge 1  integer , intent ( in ) :: m !! total number of constraints,  m \\ge 0  integer , intent ( in ) :: meq !! number of equality constraints,  m_{eq} \\ge 0  integer , intent ( in ) :: max_iter !! maximum number of iterations procedure ( func ) :: f !! problem function procedure ( grad ) :: g !! function to compute gradients real ( wp ), dimension ( n ), intent ( in ) :: xl !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xu !! upper bounds on `x` real ( wp ), intent ( in ) :: acc !! accuracy logical , intent ( out ) :: status_ok !! will be false if there were errors integer , intent ( in ), optional :: linesearch_mode !! 1 = inexact (default), 2 = exact integer , intent ( in ), optional :: iprint !! unit number of status messages (default=output_unit) procedure ( iterfunc ), optional :: report !! user-defined procedure that will be called once per iteration real ( wp ), intent ( in ), optional :: alphamin !! minimum alpha for linesearch [default 0.1] real ( wp ), intent ( in ), optional :: alphamax !! maximum alpha for linesearch [default 1.0] integer :: n1 , mineq , i status_ok = . false . call me % destroy () if ( present ( iprint )) me % iprint = iprint if ( size ( xl ) /= size ( xu ) . or . size ( xl ) /= n ) then call me % report_message ( 'error: invalid upper or lower bound vector size' ) call me % report_message ( '  size(xl) =' , ival = size ( xl )) call me % report_message ( '  size(xu) =' , ival = size ( xu )) call me % report_message ( '  n        =' , ival = n ) else if ( meq < 0 . or . meq > m ) then call me % report_message ( 'error: invalid meq value:' , ival = meq ) else if ( m < 0 ) then call me % report_message ( 'error: invalid m value:' , ival = m ) else if ( n < 1 ) then call me % report_message ( 'error: invalid n value:' , ival = n ) else if ( any ( xl > xu )) then call me % report_message ( 'error: lower bounds must be <= upper bounds.' ) do i = 1 , n if ( xl ( i ) > xu ( i )) then call me % report_message ( '  xl(i)>xu(i) for variable' , ival = i ) end if end do else if ( present ( linesearch_mode )) then !two linesearch modes: select case ( linesearch_mode ) case ( 1 ) !inexact me % linesearch_mode = linesearch_mode case ( 2 ) !exact me % linesearch_mode = linesearch_mode case default call me % report_message ( 'error: invalid linesearch_mode (must be 1 or 2): ' ,& ival = linesearch_mode ) call me % destroy () return end select end if !optional linesearch bounds: if ( present ( alphamin )) me % alphamin = alphamin if ( present ( alphamax )) me % alphamax = alphamax !verify valid values for alphamin and alphamax: 0<alphamin<alphamax<=1 if ( me % alphamin <= zero . or . me % alphamax <= zero . or . & me % alphamax <= me % alphamin . or . & me % alphamin >= one . or . me % alphamax > one ) then call me % report_message ( 'error: invalid values for alphamin or alphamax.' ) call me % report_message ( '  alphamin =' , rval = me % alphamin ) call me % report_message ( '  alphamax =' , rval = me % alphamax ) call me % destroy () return end if status_ok = . true . me % n = n me % m = m me % meq = meq me % max_iter = max_iter me % acc = acc me % f => f me % g => g if ( present ( report )) me % report => report allocate ( me % xl ( n )); me % xl = xl allocate ( me % xu ( n )); me % xu = xu !work arrays: n1 = n + 1 mineq = m - meq + 2 * n1 me % l_w = n1 * ( n1 + 1 ) + meq * ( n1 + 1 ) + mineq * ( n1 + 1 ) + & !for lsq ( n1 - meq + 1 ) * ( mineq + 2 ) + 2 * mineq + & !for lsi ( n1 + mineq ) * ( n1 - meq ) + 2 * meq + n1 + & !for lsei n1 * n / 2 + 2 * m + 3 * n + 3 * n1 + 1 !for slsqpb allocate ( me % w ( me % l_w )) me % w = zero me % l_jw = mineq allocate ( me % jw ( me % l_jw )) me % jw = 0 end if end subroutine initialize_slsqp !******************************************************************************* !******************************************************************************* !> !  destructor for [[slsqp_solver]]. subroutine destroy_slsqp ( me ) implicit none class ( slsqp_solver ), intent ( out ) :: me end subroutine destroy_slsqp !******************************************************************************* !******************************************************************************* !> !  main routine for calling [[slsqp]]. subroutine slsqp_wrapper ( me , x , istat , iterations , status_message ) implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x !! **in:**  initial optimization variables, !! **out:** solution. integer , intent ( out ) :: istat !! status code (see `mode` in [[slsqp]]). integer , intent ( out ), optional :: iterations !! number of iterations character ( len = :), intent ( out ), allocatable , optional :: status_message !! string status message corresponding to `istat` !local variables: real ( wp ) :: f !! objective function real ( wp ), dimension ( max ( 1 , me % m )) :: c !! constraint vector real ( wp ), dimension ( max ( 1 , me % m ), me % n + 1 ) :: a !! a matrix for slsqp real ( wp ), dimension ( me % n + 1 ) :: g !! g matrix for slsqp real ( wp ), dimension ( me % m ) :: cvec !! constraint vector real ( wp ), dimension ( me % n ) :: dfdx !! objective function partials real ( wp ), dimension ( me % m , me % n ) :: dcdx !! constraint partials integer :: i !! iteration counter integer :: mode !! reverse communication flag for [[slsqp]] integer :: la !! input to [[slsqp]] integer :: iter !! in/out for [[slsqp]] real ( wp ) :: acc !! in/out for [[slsqp]] !initialize: i = 0 iter = me % max_iter la = max ( 1 , me % m ) mode = 0 a = zero g = zero c = zero if ( present ( iterations )) iterations = 0 call me % linmin % destroy () call me % slsqpb % destroy () !check setup: if ( size ( x ) /= me % n ) then istat = - 100 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if !linesearch: select case ( me % linesearch_mode ) case ( 1 ) !inexact (armijo-type linesearch) acc = abs ( me % acc ) case ( 2 ) !exact acc = - abs ( me % acc ) case default istat = - 101 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end select !make sure the functions have been associated: if (. not . associated ( me % f )) then istat = - 102 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if (. not . associated ( me % g )) then istat = - 103 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if !main solver loop: do if ( mode == 0 . or . mode == 1 ) then !function evaluation (f&c) call me % f ( x , f , cvec ) c ( 1 : me % m ) = cvec end if if ( mode == 0 . or . mode ==- 1 ) then !gradient evaluation (g&a) call me % g ( x , dfdx , dcdx ) g ( 1 : me % n ) = dfdx a ( 1 : me % m , 1 : me % n ) = dcdx !this is an iteration: !note: the initial guess is reported as iteration 0: if ( associated ( me % report )) call me % report ( i , x , f , c ) !report iteration i = i + 1 ! iteration counter end if !main routine: call slsqp ( me % m , me % meq , la , me % n , x , me % xl , me % xu ,& f , c , g , a , acc , iter , mode ,& me % w , me % l_w , me % jw , me % l_jw ,& me % slsqpb , me % linmin , me % alphamin , me % alphamax ) if ( mode == 1 . or . mode ==- 1 ) then !continue to next call else if ( mode == 0 . and . associated ( me % report )) & call me % report ( i , x , f , c ) !report solution call me % report_message ( mode_to_status_message ( mode )) exit end if if ( me % user_triggered_stop ) then mode = - 2 call me % report_message ( mode_to_status_message ( mode )) me % user_triggered_stop = . false . !have to reset in case !method is called again. exit end if end do istat = mode if ( present ( iterations )) iterations = iter if ( present ( status_message )) status_message = mode_to_status_message ( istat ) end subroutine slsqp_wrapper !******************************************************************************* !******************************************************************************* !> !  Report a message from an [[slsqp_solver]] class. This uses the `iprint` !  variable in the class as the unit number for printing. Note: for fatal errors, !  if no unit is specified, the `error_unit` is used. subroutine report_message ( me , str , ival , rval , fatal ) implicit none class ( slsqp_solver ), intent ( in ) :: me character ( len =* ), intent ( in ) :: str !! the message to report. integer , intent ( in ), optional :: ival !! optional integer to print after the message. real ( wp ), intent ( in ), optional :: rval !! optional real to print after the message. logical , intent ( in ), optional :: fatal !! if True, then the program is stopped (default=False). logical :: stop_program !! true if the program is to be stopped logical :: write_message !! true if the message is to be printed character ( len = 10 ) :: istr !! string version of `ival` character ( len = 30 ) :: rstr !! string version of `rval` character ( len = :), allocatable :: str_to_write !! the actual message to the printed integer :: istat !! iostat for integer to string conversion !fatal error check: if ( present ( fatal )) then stop_program = fatal else stop_program = . false . end if !note: if stopping program, then the message is always printed: write_message = me % iprint /= 0 . or . stop_program if ( write_message ) then if ( present ( ival )) then write ( istr , fmt = '(I10)' , iostat = istat ) ival if ( istat /= 0 ) istr = '*****' str_to_write = str // ' ' // trim ( adjustl ( istr )) elseif ( present ( rval )) then write ( istr , fmt = '(F30.16)' , iostat = istat ) rval if ( istat /= 0 ) rstr = '*****' str_to_write = str // ' ' // trim ( adjustl ( rstr )) else str_to_write = str end if if ( me % iprint == 0 ) then write ( error_unit , '(A)' ) str_to_write !in this case, use the error unit else write ( me % iprint , '(A)' ) str_to_write !user specified unit number end if deallocate ( str_to_write ) if ( stop_program ) error stop 'Fatal Error' end if end subroutine report_message !******************************************************************************* !******************************************************************************* !> !  Convert the [[slsqp]] `mode` flag to a message string. pure function mode_to_status_message ( imode ) result ( message ) implicit none integer , intent ( in ) :: imode character ( len = :), allocatable :: message select case ( imode ) case ( 0 ) !required accuracy for solution obtained message = 'Required accuracy for solution obtained' case ( - 100 ) message = 'Invalid size(x) in slsqp_wrapper' case ( - 101 ) message = 'Invalid linesearch_mode in slsqp_wrapper' case ( - 102 ) message = 'Function is not associated' case ( - 103 ) message = 'Gradient function is not associated' case ( - 2 ) message = 'User-triggered stop of slsqp' case ( 1 , - 1 ) message = 'In progress' case ( 2 ) message = 'Number of equality constraints larger than n' case ( 3 ) message = 'More than 3*n iterations in lsq subproblem' case ( 4 ) message = 'Inequality constraints incompatible' case ( 5 ) message = 'Singular matrix e in lsq subproblem' case ( 6 ) message = 'Singular matrix c in lsq subproblem' case ( 7 ) message = 'Rank-deficient equality constraint subproblem hfti' case ( 8 ) message = 'Positive directional derivative for linesearch' case ( 9 ) message = 'More than max_iter iterations in slsqp' case default message = 'Unknown slsqp error' end select end function mode_to_status_message !******************************************************************************* !******************************************************************************* end module slsqp_module !*******************************************************************************","tags":"","loc":"sourcefile/slsqp_module.f90.html","title":"slsqp_module.f90 – slsqp"},{"text":"This File Depends On sourcefile~~slsqp_core.f90~~EfferentGraph sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_kinds.f90 slsqp_kinds.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_support.f90 slsqp_support.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_core.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~slsqp_core.f90~~AfferentGraph sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_module.f90 sourcefile~slsqp_test_2.f90 slsqp_test_2.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_test_2.f90 sourcefile~slsqp_test.f90 slsqp_test.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_test.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules slsqp_core Source Code slsqp_core.f90 Source Code !******************************************************************************* !> license: BSD ! !  Core subroutines for the SLSQP optimization method. !  These are refactoried versions of the original routines. module slsqp_core use slsqp_kinds use slsqp_support implicit none private type , public :: linmin_data !! data formerly saved in [[linmin]] routine. real ( wp ) :: a = zero real ( wp ) :: b = zero real ( wp ) :: d = zero real ( wp ) :: e = zero real ( wp ) :: p = zero real ( wp ) :: q = zero real ( wp ) :: r = zero real ( wp ) :: u = zero real ( wp ) :: v = zero real ( wp ) :: w = zero real ( wp ) :: x = zero real ( wp ) :: m = zero real ( wp ) :: fu = zero real ( wp ) :: fv = zero real ( wp ) :: fw = zero real ( wp ) :: fx = zero real ( wp ) :: tol1 = zero real ( wp ) :: tol2 = zero contains procedure :: destroy => destroy_linmin_data end type linmin_data type , public :: slsqpb_data !! data formerly saved in [[slsqpb]]. real ( wp ) :: t = zero real ( wp ) :: f0 = zero real ( wp ) :: h1 = zero real ( wp ) :: h2 = zero real ( wp ) :: h3 = zero real ( wp ) :: h4 = zero real ( wp ) :: t0 = zero real ( wp ) :: gs = zero real ( wp ) :: tol = zero real ( wp ) :: alpha = zero integer :: line = 0 integer :: iexact = 0 integer :: incons = 0 integer :: ireset = 0 integer :: itermx = 0 integer :: n1 = 0 integer :: n2 = 0 integer :: n3 = 0 contains procedure :: destroy => destroy_slsqpb_data end type slsqpb_data public :: slsqp contains !******************************************************************************* !******************************************************************************* !> !  **slsqp**: **s**equential **l**east **sq**uares **p**rogramming !  to solve general nonlinear optimization problems ! !  a nonlinear programming method with quadratic programming subproblems !  this subroutine solves the general nonlinear programming problem: ! !  **minimize** ! !  *  f(x)  ! !  **subject to** ! !  *  c_j (x) = 0 ,            j = 1,...,meq    !  *  c_j (x) \\ge 0 ,          j = meq+1,...,m  !  *  xl_i \\le x_i \\le xu_i ,  i = 1,...,n      ! !  the algorithm implements the method of Han and Powell !  with BFGS-update of the b-matrix and L1-test function !  within the steplength algorithm. ! !### Reference !   * Dieter Kraft: \"A software package for sequential quadratic programming\", !     DFVLR-FB 88-28, 1988 ! !### History !   * implemented by: Dieter Kraft, DFVLR oberpfaffenhofen !   * date: april - october, 1981. !   * December, 31-st, 1984. !   * March   , 21-st, 1987, revised to fortran 77 !   * March   , 20-th, 1989, revised to ms-fortran !   * April   , 14-th, 1989, hesse   in-line coded !   * February, 28-th, 1991, fortran/2 version 1.04 accepts statement functions !   * March   ,  1-st, 1991, tested with salford ftn77/386 compiler vers 2.40 in protected mode !   * January ,        2016, Refactored into modern Fortran by Jacob Williams ! !### License !  Original version copyright 1991: Dieter Kraft, FHM. !  Released under a BSD license. ! !@note `f`, `c`, `g`, `a` must all be set by the user before each call. subroutine slsqp ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode , w , l_w , & jw , l_jw , sdat , ldat , alphamin , alphamax ) implicit none integer , intent ( in ) :: m !! is the total number of constraints,  m \\ge 0  integer , intent ( in ) :: meq !! is the number of equality constraints,  m_{eq} \\ge 0  integer , intent ( in ) :: la !! see `a`,  la \\ge \\max(m,1)  integer , intent ( in ) :: n !! is the number of variables,  n \\ge 1  real ( wp ), dimension ( n ), intent ( inout ) :: x !! `x()` stores the current iterate of the `n` vector `x` !! on entry `x()` must be initialized. on exit `x()` !! stores the solution vector `x` if `mode = 0`. real ( wp ), dimension ( n ), intent ( in ) :: xl !! `xl()` stores an n vector of lower bounds `xl` to `x`. real ( wp ), dimension ( n ), intent ( in ) :: xu !! `xu()` stores an n vector of upper bounds `xu` to `x`. real ( wp ), intent ( in ) :: f !! is the value of the objective function. real ( wp ), dimension ( la ), intent ( in ) :: c !! `c()` stores the `m` vector `c` of constraints, !! equality constraints (if any) first. !! dimension of `c` must be greater or equal `la`, !! which must be greater or equal `max(1,m)`. real ( wp ), dimension ( n + 1 ), intent ( in ) :: g !! `g()` stores the `n` vector `g` of partials of the !! objective function; dimension of `g` must be !! greater or equal `n+1`. real ( wp ), dimension ( la , n + 1 ), intent ( in ) :: a !! the `la` by `n + 1` array `a()` stores !! the `m` by `n` matrix `a` of constraint normals. !! `a()` has first dimensioning parameter `la`, !! which must be greater or equal `max(1,m)`. real ( wp ), intent ( inout ) :: acc !! `abs(acc)` controls the final accuracy. !! if `acc` < zero an exact linesearch is performed, !! otherwise an armijo-type linesearch is used. integer , intent ( inout ) :: iter !! prescribes the maximum number of iterations. !! on exit `iter` indicates the number of iterations. integer , intent ( inout ) :: mode !! mode controls calculation: !! !! reverse communication is used in the sense that !! the program is initialized by `mode = 0`; then it is !! to be called repeatedly by the user until a return !! with `mode /= abs(1)` takes place. !! if `mode = -1` gradients have to be calculated, !! while with `mode = 1` functions have to be calculated. !! mode must not be changed between subsequent calls of [[slsqp]]. !! !! **evaluation modes**: !! !! * ** -1 **: gradient evaluation, (`g` & `a`) !! * **  0 **: *on entry*: initialization, (`f`, `g`, `c`, `a`), !!   *on exit*: required accuracy for solution obtained !! * **  1 **: function evaluation, (`f` & `c`) !! !! **failure modes**: !! !! * ** 2 **: number of equality constraints larger than `n` !! * ** 3 **: more than `3*n` iterations in [[lsq]] subproblem !! * ** 4 **: inequality constraints incompatible !! * ** 5 **: singular matrix `e` in [[lsq]] subproblem !! * ** 6 **: singular matrix `c` in [[lsq]] subproblem !! * ** 7 **: rank-deficient equality constraint subproblem [[hfti]] !! * ** 8 **: positive directional derivative for linesearch !! * ** 9 **: more than `iter` iterations in sqp !! * ** >=10 **: working space `w` or `jw` too small, !!   `w` should be enlarged to `l_w=mode/1000`, !!   `jw` should be enlarged to `l_jw=mode-1000*l_w` integer , intent ( in ) :: l_w !! the length of `w`, which should be at least: !! !! * `(3*n1+m)*(n1+1)`                     **for lsq** !! * `+(n1-meq+1)*(mineq+2) + 2*mineq`     **for lsi** !! * `+(n1+mineq)*(n1-meq) + 2*meq + n1`   **for lsei** !! * `+ n1*n/2 + 2*m + 3*n + 3*n1 + 1`     **for slsqpb** !! !! with `mineq = m - meq + 2*n1` & `n1 = n+1` integer , intent ( in ) :: l_jw !! the length of `jw` which should be at least !! `mineq = m - meq + 2*(n+1)`. real ( wp ), dimension ( l_w ), intent ( inout ) :: w !! `w()` is a one dimensional working space. !! the first `m+n+n*n1/2` elements of `w` must not be !! changed between subsequent calls of [[slsqp]]. !! on return `w(1) ... w(m)` contain the multipliers !! associated with the general constraints, while !! `w(m+1) ... w(m+n(n+1)/2)` store the cholesky factor !! `l*d*l(t)` of the approximate hessian of the !! lagrangian columnwise dense as lower triangular !! unit matrix `l` with `d` in its 'diagonal' and !! `w(m+n(n+1)/2+n+2 ... w(m+n(n+1)/2+n+2+m+2n)` !! contain the multipliers associated with all !! constraints of the quadratic program finding !! the search direction to the solution `x*` integer , dimension ( l_jw ), intent ( inout ) :: jw !! `jw()` is a one dimensional integer working space type ( slsqpb_data ), intent ( inout ) :: sdat !! data for [[slsqpb]]. type ( linmin_data ), intent ( inout ) :: ldat !! data for [[linmin]]. real ( wp ), intent ( in ) :: alphamin !! min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: alphamax !! max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  integer :: il , im , ir , is , iu , iv , iw , ix , mineq , n1 !   check length of working arrays n1 = n + 1 mineq = m - meq + n1 + n1 il = ( 3 * n1 + m ) * ( n1 + 1 ) + ( n1 - meq + 1 ) * ( mineq + 2 ) + 2 * mineq + ( n1 + mineq )& * ( n1 - meq ) + 2 * meq + n1 * n / 2 + 2 * m + 3 * n + 4 * n1 + 1 im = max ( mineq , n1 - meq ) if ( l_w < il . or . l_jw < im ) then mode = 1000 * max ( 10 , il ) mode = mode + max ( 10 , im ) return end if if ( meq > n ) then ! note: calling lsq when meq>n is corrupting the ! memory in some way, so just catch this here. mode = 2 return end if !   prepare data for calling sqpbdy  -  initial addresses in w im = 1 il = im + max ( 1 , m ) il = im + la ix = il + n1 * n / 2 + 1 ir = ix + n is = ir + n + n + max ( 1 , m ) is = ir + n + n + la iu = is + n1 iv = iu + n1 iw = iv + n1 sdat % n1 = n1 call slsqpb ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode ,& w ( ir ), w ( il ), w ( ix ), w ( im ), w ( is ), w ( iu ), w ( iv ), w ( iw ), jw ,& sdat % t , sdat % f0 , sdat % h1 , sdat % h2 , sdat % h3 , sdat % h4 ,& sdat % n1 , sdat % n2 , sdat % n3 , sdat % t0 , sdat % gs , sdat % tol , sdat % line ,& sdat % alpha , sdat % iexact , sdat % incons , sdat % ireset , sdat % itermx ,& ldat , alphamin , alphamax ) end subroutine slsqp !******************************************************************************* !******************************************************************************* !> !  nonlinear programming by solving sequentially quadratic programs ! !  l1 - line search, positive definite bfgs update subroutine slsqpb ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode ,& r , l , x0 , mu , s , u , v , w , iw ,& t , f0 , h1 , h2 , h3 , h4 , n1 , n2 , n3 , t0 , gs , tol , line ,& alpha , iexact , incons , ireset , itermx , ldat ,& alphamin , alphamax ) implicit none integer , intent ( in ) :: m integer , intent ( in ) :: meq integer , intent ( in ) :: la integer , intent ( in ) :: n real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( n ) :: xl real ( wp ), dimension ( n ) :: xu real ( wp ) :: f real ( wp ), dimension ( la ) :: c real ( wp ), dimension ( n + 1 ) :: g real ( wp ), dimension ( la , n + 1 ) :: a real ( wp ) :: acc integer , intent ( inout ) :: iter !! **in:**  maximum number of iterations. !! **out:** actual number of iterations. integer , intent ( inout ) :: mode real ( wp ), dimension ( m + n + n + 2 ) :: r real ( wp ), dimension (( n + 1 ) * ( n + 2 ) / 2 ) :: l real ( wp ), dimension ( n ) :: x0 real ( wp ), dimension ( la ) :: mu real ( wp ), dimension ( n + 1 ) :: s real ( wp ), dimension ( n + 1 ) :: u real ( wp ), dimension ( n + 1 ) :: v real ( wp ), dimension ( * ), intent ( inout ) :: w !! `dim(w)` = !! !! * `n1*(n1+1) + meq*(n1+1) + mineq*(n1+1)`   for [[lsq]] !! * `+(n1-meq+1)*(mineq+2) + 2*mineq`         for [[lsi]] !! * `+(n1+mineq)*(n1-meq) + 2*meq + n1`       for [[lsei]] !! !! with `mineq = m - meq + 2*n1` & `n1 = n+1` integer , dimension ( * ), intent ( inout ) :: iw real ( wp ), intent ( inout ) :: t real ( wp ), intent ( inout ) :: f0 real ( wp ), intent ( inout ) :: h1 real ( wp ), intent ( inout ) :: h2 real ( wp ), intent ( inout ) :: h3 real ( wp ), intent ( inout ) :: h4 integer , intent ( inout ) :: n1 integer , intent ( inout ) :: n2 integer , intent ( inout ) :: n3 real ( wp ), intent ( inout ) :: t0 real ( wp ), intent ( inout ) :: gs real ( wp ), intent ( inout ) :: tol integer , intent ( inout ) :: line real ( wp ), intent ( inout ) :: alpha integer , intent ( inout ) :: iexact integer , intent ( inout ) :: incons integer , intent ( inout ) :: ireset integer , intent ( inout ) :: itermx type ( linmin_data ), intent ( inout ) :: ldat !! data for [[linmin]]. real ( wp ), intent ( in ) :: alphamin !! min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: alphamax !! max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  integer :: i , j , k if ( mode < 0 ) then ! call jacobian at current x ! update cholesky-factors of hessian matrix by modified bfgs formula do i = 1 , n u ( i ) = g ( i ) - ddot ( m , a ( 1 , i ), 1 , r , 1 ) - v ( i ) end do ! l'*s k = 0 do i = 1 , n h1 = zero k = k + 1 do j = i + 1 , n k = k + 1 h1 = h1 + l ( k ) * s ( j ) end do v ( i ) = s ( i ) + h1 end do ! d*l'*s k = 1 do i = 1 , n v ( i ) = l ( k ) * v ( i ) k = k + n1 - i end do ! l*d*l'*s do i = n , 1 , - 1 h1 = zero k = i do j = 1 , i - 1 h1 = h1 + l ( k ) * v ( j ) k = k + n - j end do v ( i ) = v ( i ) + h1 end do h1 = ddot ( n , s , 1 , u , 1 ) h2 = ddot ( n , s , 1 , v , 1 ) h3 = 0.2_wp * h2 if ( h1 < h3 ) then h4 = ( h2 - h3 ) / ( h2 - h1 ) h1 = h3 call dscal ( n , h4 , u , 1 ) call daxpy ( n , one - h4 , v , 1 , u , 1 ) end if call ldl ( n , l , u , + one / h1 , v ) call ldl ( n , l , v , - one / h2 , u ) ! end of main iteration goto 200 else if ( mode == 0 ) then itermx = iter if ( acc >= zero ) then iexact = 0 else iexact = 1 end if acc = abs ( acc ) tol = ten * acc iter = 0 ireset = 0 n1 = n + 1 n2 = n1 * n / 2 n3 = n2 + 1 s ( 1 ) = zero mu ( 1 ) = zero call dcopy ( n , s ( 1 ), 0 , s , 1 ) call dcopy ( m , mu ( 1 ), 0 , mu , 1 ) else ! call functions at current x t = f do j = 1 , m if ( j <= meq ) then h1 = c ( j ) else h1 = zero end if t = t + mu ( j ) * max ( - c ( j ), h1 ) end do h1 = t - t0 if ( iexact + 1 == 1 ) then if ( h1 <= h3 / ten . or . line > 10 ) goto 500 alpha = min ( max ( h3 / ( two * ( h3 - h1 )), alphamin ), alphamax ) goto 300 else if ( iexact + 1 == 2 ) then goto 400 else goto 500 end if end if ! reset bfgs matrix 100 ireset = ireset + 1 if ( ireset > 5 ) then ! check relaxed convergence in case of positive directional derivative if ( ( abs ( f - f0 ) < tol . or . dnrm2 ( n , s , 1 ) < tol ) . and . h3 < tol ) then mode = 0 else mode = 8 end if return else l ( 1 ) = zero call dcopy ( n2 , l ( 1 ), 0 , l , 1 ) j = 1 do i = 1 , n l ( j ) = one j = j + n1 - i end do end if ! main iteration : search direction, steplength, ldl'-update 200 iter = iter + 1 mode = 9 if ( iter > itermx ) return ! search direction as solution of qp - subproblem call dcopy ( n , xl , 1 , u , 1 ) call dcopy ( n , xu , 1 , v , 1 ) call daxpy ( n , - one , x , 1 , u , 1 ) call daxpy ( n , - one , x , 1 , v , 1 ) h4 = one call lsq ( m , meq , n , n3 , la , l , g , a , c , u , v , s , r , w , iw , mode ) ! augmented problem for inconsistent linearization if ( mode == 6 ) then if ( n == meq ) mode = 4 end if if ( mode == 4 ) then do j = 1 , m if ( j <= meq ) then a ( j , n1 ) = - c ( j ) else a ( j , n1 ) = max ( - c ( j ), zero ) end if end do s ( 1 ) = zero call dcopy ( n , s ( 1 ), 0 , s , 1 ) h3 = zero g ( n1 ) = zero l ( n3 ) = hun s ( n1 ) = one u ( n1 ) = zero v ( n1 ) = one incons = 0 250 call lsq ( m , meq , n1 , n3 , la , l , g , a , c , u , v , s , r , w , iw , mode ) h4 = one - s ( n1 ) if ( mode == 4 ) then l ( n3 ) = ten * l ( n3 ) incons = incons + 1 if ( incons <= 5 ) goto 250 return else if ( mode /= 1 ) then return end if else if ( mode /= 1 ) then return end if ! update multipliers for l1-test do i = 1 , n v ( i ) = g ( i ) - ddot ( m , a ( 1 , i ), 1 , r , 1 ) end do f0 = f call dcopy ( n , x , 1 , x0 , 1 ) gs = ddot ( n , g , 1 , s , 1 ) h1 = abs ( gs ) h2 = zero do j = 1 , m if ( j <= meq ) then h3 = c ( j ) else h3 = zero end if h2 = h2 + max ( - c ( j ), h3 ) h3 = abs ( r ( j )) mu ( j ) = max ( h3 ,( mu ( j ) + h3 ) / two ) h1 = h1 + h3 * abs ( c ( j )) end do ! check convergence mode = 0 if ( h1 < acc . and . h2 < acc ) return h1 = zero do j = 1 , m if ( j <= meq ) then h3 = c ( j ) else h3 = zero end if h1 = h1 + mu ( j ) * max ( - c ( j ), h3 ) end do t0 = f + h1 h3 = gs - h1 * h4 mode = 8 if ( h3 >= zero ) goto 100 ! line search with an l1-testfunction line = 0 alpha = alphamax if ( iexact == 1 ) goto 400 ! inexact linesearch 300 line = line + 1 h3 = alpha * h3 call dscal ( n , alpha , s , 1 ) call dcopy ( n , x0 , 1 , x , 1 ) call daxpy ( n , one , s , 1 , x , 1 ) call enforce_bounds ( x , xl , xu ) ! ensure that x doesn't violate bounds mode = 1 return ! exact linesearch 400 if ( line /= 3 ) then alpha = linmin ( line , alphamin , alphamax , t , tol , & ldat % a , ldat % b , ldat % d , ldat % e , ldat % p , ldat % q , & ldat % r , ldat % u , ldat % v , ldat % w , ldat % x , ldat % m , & ldat % fu , ldat % fv , ldat % fw , ldat % fx , ldat % tol1 , ldat % tol2 ) call dcopy ( n , x0 , 1 , x , 1 ) call daxpy ( n , alpha , s , 1 , x , 1 ) mode = 1 return end if call dscal ( n , alpha , s , 1 ) ! check convergence 500 h3 = zero do j = 1 , m if ( j <= meq ) then h1 = c ( j ) else h1 = zero end if h3 = h3 + max ( - c ( j ), h1 ) end do if ( ( abs ( f - f0 ) < acc . or . dnrm2 ( n , s , 1 ) < acc ) . and . h3 < acc ) then mode = 0 else mode = - 1 end if end subroutine slsqpb !******************************************************************************* !******************************************************************************* !> !  Minimize  || e x - f ||  with respect to x, !  with upper triangular matrix  e = + d &#94;{1/2} l&#94;T , !  and vector  f = -d&#94;{-1/2} l&#94;{-1} g , !  where the unit lower tridiangular matrix l is stored columnwise !  dense in the n*(n+1)/2 array l with vector d stored in its !  'diagonal' thus substituting the one-elements of l ! !  subject to: ! !  *  a(j)*x - b(j) = 0,              j=1,...,meq  , !  *  a(j)*x - b(j) \\ge 0,            j=meq+1,...,m, !  *  x_l(i) \\le x(i) \\le x_u(i),     i=1,...,n    , ! !  On entry, the user has to provide the arrays `l`, `g`, `a`, `b`, `xl`, `xu`. !  with dimensions: `l(n*(n+1)/2)`, `g(n)`, `a(la,n)`, `b(m)`, `xl(n)`, `xu(n)`. ! !  The working array `w` must have at least the following dimension: dim(w) = ! !  * `(3*n+m)*(n+1)`                    for [[lsq]] !  * `+(n-meq+1)*(mineq+2) + 2*mineq`   for [[lsi]] !  * `+(n+mineq)*(n-meq) + 2*meq + n`   for [[lsei]] ! !  with `mineq = m - meq + 2*n` ! !  On return, no array will be changed by the subroutine. ! !### History !  * coded dieter kraft, april 1987 !  * revised march 1989 subroutine lsq ( m , meq , n , nl , la , l , g , a , b , xl , xu , x , y , w , jw , mode ) implicit none integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: meq integer , intent ( in ) :: nl integer , intent ( in ) :: la real ( wp ), dimension ( n ) :: x !! stores the n-dimensional solution vector real ( wp ), dimension ( m + n + n ) :: y !! stores the vector of lagrange multipliers of dimension !! m+n+n (constraints+lower+upper bounds) integer :: mode !! is a success-failure flag with the following meanings: !! !! * **1:** successful computation, !! * **2:** error return because of wrong dimensions (`n<1`), !! * **3:** iteration count exceeded by [[nnls]], !! * **4:** inequality constraints incompatible, !! * **5:** matrix `e` is not of full rank, !! * **6:** matrix `c` is not of full rank, !! * **7:** rank defect in [[hfti]] real ( wp ), dimension ( nl ) :: l real ( wp ), dimension ( n ) :: g real ( wp ), dimension ( la , n ) :: a real ( wp ), dimension ( la ) :: b real ( wp ), dimension ( * ) :: w real ( wp ), dimension ( n ) :: xl real ( wp ), dimension ( n ) :: xu integer , dimension ( * ) :: jw real ( wp ) :: diag , xnorm integer :: i , ic , id , ie , if , ig , ih , il , im , ip , & iu , iw , i1 , i2 , i3 , i4 , mineq , & m1 , n1 , n2 , n3 n1 = n + 1 mineq = m - meq m1 = mineq + n + n !  determine whether to solve problem !  with inconsistent linerarization (n2=1) !  or not (n2=0) n2 = n1 * n / 2 + 1 if ( n2 == nl ) then n2 = 0 else n2 = 1 end if n3 = n - n2 !  recover matrix e and vector f from l and g i2 = 1 i3 = 1 i4 = 1 ie = 1 if = n * n + 1 do i = 1 , n3 i1 = n1 - i diag = sqrt ( l ( i2 )) w ( i3 ) = zero call dcopy ( i1 , w ( i3 ), 0 , w ( i3 ), 1 ) call dcopy ( i1 - n2 , l ( i2 ), 1 , w ( i3 ), n ) call dscal ( i1 - n2 , diag , w ( i3 ), n ) w ( i3 ) = diag w ( if - 1 + i ) = ( g ( i ) - ddot ( i - 1 , w ( i4 ), 1 , w ( if ), 1 )) / diag i2 = i2 + i1 - n2 i3 = i3 + n1 i4 = i4 + n end do if ( n2 == 1 ) then w ( i3 ) = l ( nl ) w ( i4 ) = zero call dcopy ( n3 , w ( i4 ), 0 , w ( i4 ), 1 ) w ( if - 1 + n ) = zero end if call dscal ( n , - one , w ( if ), 1 ) ic = if + n id = ic + meq * n if ( meq > 0 ) then !  recover matrix c from upper part of a do i = 1 , meq call dcopy ( n , a ( i , 1 ), la , w ( ic - 1 + i ), meq ) end do !  recover vector d from upper part of b call dcopy ( meq , b ( 1 ), 1 , w ( id ), 1 ) call dscal ( meq , - one , w ( id ), 1 ) end if ig = id + meq if ( mineq > 0 ) then !  recover matrix g from lower part of a do i = 1 , mineq call dcopy ( n , a ( meq + i , 1 ), la , w ( ig - 1 + i ), m1 ) end do end if !  augment matrix g by +i and -i ip = ig + mineq do i = 1 , n w ( ip - 1 + i ) = zero call dcopy ( n , w ( ip - 1 + i ), 0 , w ( ip - 1 + i ), m1 ) end do w ( ip ) = one call dcopy ( n , w ( ip ), 0 , w ( ip ), m1 + 1 ) im = ip + n do i = 1 , n w ( im - 1 + i ) = zero call dcopy ( n , w ( im - 1 + i ), 0 , w ( im - 1 + i ), m1 ) end do w ( im ) = - one call dcopy ( n , w ( im ), 0 , w ( im ), m1 + 1 ) ih = ig + m1 * n if ( mineq > 0 ) then ! recover h from lower part of b call dcopy ( mineq , b ( meq + 1 ), 1 , w ( ih ), 1 ) call dscal ( mineq , - one , w ( ih ), 1 ) end if !  augment vector h by xl and xu il = ih + mineq call dcopy ( n , xl , 1 , w ( il ), 1 ) iu = il + n call dcopy ( n , xu , 1 , w ( iu ), 1 ) call dscal ( n , - one , w ( iu ), 1 ) iw = iu + n call lsei ( w ( ic ), w ( id ), w ( ie ), w ( if ), w ( ig ), w ( ih ), max ( 1 , meq ), meq , n , n , & m1 , m1 , n , x , xnorm , w ( iw ), jw , mode ) if ( mode == 1 ) then ! restore lagrange multipliers call dcopy ( m , w ( iw ), 1 , y ( 1 ), 1 ) call dcopy ( n3 , w ( iw + m ), 1 , y ( m + 1 ), 1 ) call dcopy ( n3 , w ( iw + m + n ), 1 , y ( m + n3 + 1 ), 1 ) call enforce_bounds ( x , xl , xu ) ! to ensure that bounds are not violated end if end subroutine lsq !******************************************************************************* !******************************************************************************* !> !  for `mode=1`, the subroutine returns the solution `x` of !  equality & inequality constrained least squares problem lsei : ! !   \\underset{x}{\\min} ||E x - f||  ! !  s.t.   C x  = d   and  G x \\ge h . ! !  using QR decomposition & orthogonal basis of nullspace of  C . ! !  The following dimensions of the arrays defining the problem !  are necessary: !```` !        dim(c) :   formal (lc,n),    actual (mc,n) !        dim(d) :   formal (lc  ),    actual (mc  ) !        dim(e) :   formal (le,n),    actual (me,n) !        dim(f) :   formal (le  ),    actual (me  ) !        dim(g) :   formal (lg,n),    actual (mg,n) !        dim(h) :   formal (lg  ),    actual (mg  ) !        dim(x) :   formal (n   ),    actual (n   ) !        dim(w) :   2*mc+me+(me+mg)*(n-mc)  for lsei !                 +(n-mc+1)*(mg+2)+2*mg     for lsi !        dim(jw):   max(mg,l) !```` ! !  On entry, the user has to provide the arrays C, d, E, f, G, and h. !  On return, all arrays will be changed by the subroutine. ! !### Reference !  * Chapter 23.6 of Lawson & Hanson: Solving least squares problems. ! !### History !  * 18.5.1981, dieter kraft, dfvlr oberpfaffenhofen !  * 20.3.1987, dieter kraft, dfvlr oberpfaffenhofen subroutine lsei ( c , d , e , f , g , h , lc , mc , le , me , lg , mg , n , x , xnrm , w , jw , mode ) implicit none integer , intent ( in ) :: lc integer , intent ( in ) :: mc integer , intent ( in ) :: le integer , intent ( in ) :: me integer , intent ( in ) :: lg integer , intent ( in ) :: mg integer , intent ( in ) :: n real ( wp ), dimension ( lc , n ), intent ( inout ) :: c real ( wp ), dimension ( lc ) , intent ( inout ) :: d real ( wp ), dimension ( le , n ), intent ( inout ) :: e real ( wp ), dimension ( le ) , intent ( inout ) :: f real ( wp ), dimension ( lg , n ), intent ( inout ) :: g real ( wp ), dimension ( lg ) , intent ( inout ) :: h real ( wp ), dimension ( n ) , intent ( out ) :: x !! stores the solution vector real ( wp ), intent ( out ) :: xnrm !! stores the residuum of the solution in euclidian norm real ( wp ), dimension ( * ) , intent ( inout ) :: w !! on return, stores the vector of lagrange multipliers !! in its first `mc+mg` elements integer , dimension ( * ) , intent ( inout ) :: jw integer , intent ( out ) :: mode !! is a success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<1`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible, !! * ***5:*** matrix `e` is not of full rank, !! * ***6:*** matrix `c` is not of full rank, !! * ***7:*** rank defect in [[hfti]] integer :: i , ie , if , ig , iw , j , k , krank , l , mc1 real ( wp ) :: t , dum ( 1 ) mode = 2 if ( mc <= n ) then l = n - mc mc1 = mc + 1 iw = ( l + 1 ) * ( mg + 2 ) + 2 * mg + mc ie = iw + mc + 1 if = ie + me * l ig = if + me !  triangularize c and apply factors to e and g do i = 1 , mc j = min ( i + 1 , lc ) call h12 ( 1 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), c ( j , 1 ), lc , 1 , mc - i ) call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), e , le , 1 , me ) call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), g , lg , 1 , mg ) end do !  solve c*x=d and modify f mode = 6 do i = 1 , mc if ( abs ( c ( i , i )) < epmach ) return x ( i ) = ( d ( i ) - ddot ( i - 1 , c ( i , 1 ), lc , x , 1 )) / c ( i , i ) end do mode = 1 w ( mc1 ) = zero !call dcopy(mg-mc,w(mc1),0,w(mc1),1)  ! original code call dcopy ( mg , w ( mc1 ), 0 , w ( mc1 ), 1 ) ! bug fix for when meq = n if ( mc /= n ) then do i = 1 , me w ( if - 1 + i ) = f ( i ) - ddot ( mc , e ( i , 1 ), le , x , 1 ) end do !  store transformed e & g do i = 1 , me call dcopy ( l , e ( i , mc1 ), le , w ( ie - 1 + i ), me ) end do do i = 1 , mg call dcopy ( l , g ( i , mc1 ), lg , w ( ig - 1 + i ), mg ) end do if ( mg > 0 ) then !  modify h and solve inequality constrained ls problem do i = 1 , mg h ( i ) = h ( i ) - ddot ( mc , g ( i , 1 ), lg , x , 1 ) end do call lsi ( w ( ie ), w ( if ), w ( ig ), h , me , me , mg , mg , l , x ( mc1 ), xnrm , & w ( mc1 ), jw , mode ) if ( mc == 0 ) return t = dnrm2 ( mc , x , 1 ) xnrm = sqrt ( xnrm * xnrm + t * t ) if ( mode /= 1 ) return else ! solve ls without inequality constraints mode = 7 k = max ( le , n ) t = sqrt ( epmach ) call hfti ( w ( ie ), me , me , l , w ( if ), k , 1 , t , krank , dum , w , w ( l + 1 ), jw ) xnrm = dum ( 1 ) call dcopy ( l , w ( if ), 1 , x ( mc1 ), 1 ) if ( krank /= l ) return mode = 1 end if end if !  solution of original problem and lagrange multipliers do i = 1 , me f ( i ) = ddot ( n , e ( i , 1 ), le , x , 1 ) - f ( i ) end do do i = 1 , mc d ( i ) = ddot ( me , e ( 1 , i ), 1 , f , 1 ) & - ddot ( mg , g ( 1 , i ), 1 , w ( mc1 ), 1 ) end do do i = mc , 1 , - 1 call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), x , 1 , 1 , 1 ) end do do i = mc , 1 , - 1 j = min ( i + 1 , lc ) w ( i ) = ( d ( i ) - ddot ( mc - i , c ( j , i ), 1 , w ( j ), 1 )) / c ( i , i ) end do end if end subroutine lsei !******************************************************************************* !******************************************************************************* !> !  for `mode=1`, the subroutine returns the solution `x` of !  inequality constrained linear least squares problem: ! !   \\underset{x}{\\min} ||E x - f||  ! !  s.t.  G x \\ge h . ! !  the following dimensions of the arrays defining the problem !  are necessary: !```` !     dim(e) :   formal (le,n),    actual (me,n) !     dim(f) :   formal (le  ),    actual (me  ) !     dim(g) :   formal (lg,n),    actual (mg,n) !     dim(h) :   formal (lg  ),    actual (mg  ) !     dim(x) :   n !     dim(w) :   (n+1)*(mg+2) + 2*mg !     dim(jw):   lg !```` ! !  on entry, the user has to provide the arrays `e`, `f`, `g`, and `h`. !  on return, all arrays will be changed by the subroutine. ! !### Reference !  * Chapter 23.6 of Lawson & Hanson: Solving least squares problems. ! !### History !  * 03.01.1980, dieter kraft: coded !  * 20.03.1987, dieter kraft: revised to fortran 77 subroutine lsi ( e , f , g , h , le , me , lg , mg , n , x , xnorm , w , jw , mode ) implicit none integer , intent ( in ) :: le integer , intent ( in ) :: me integer , intent ( in ) :: lg integer , intent ( in ) :: mg integer , intent ( in ) :: n real ( wp ), dimension ( le , n ), intent ( inout ) :: e real ( wp ), dimension ( le ) , intent ( inout ) :: f real ( wp ), dimension ( lg , n ), intent ( inout ) :: g real ( wp ), dimension ( lg ) , intent ( inout ) :: h real ( wp ), dimension ( n ) , intent ( out ) :: x !! stores the solution vector real ( wp ), intent ( out ) :: xnorm !! stores the residuum of the solution in euclidian norm real ( wp ), dimension ( * ) , intent ( inout ) :: w !! stores the vector of lagrange multipliers in its first !! `mg` elements integer , dimension ( lg ) , intent ( inout ) :: jw integer , intent ( out ) :: mode !! is a success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<1`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible, !! * ***5:*** matrix `e` is not of full rank. integer :: i , j real ( wp ) :: t !  qr-factors of e and application to f do i = 1 , n j = min ( i + 1 , n ) call h12 ( 1 , i , i + 1 , me , e ( 1 , i ), 1 , t , e ( 1 , j ), 1 , le , n - i ) call h12 ( 2 , i , i + 1 , me , e ( 1 , i ), 1 , t , f , 1 , 1 , 1 ) end do !  transform g and h to get least distance problem mode = 5 do i = 1 , mg do j = 1 , n if ( abs ( e ( j , j )) < epmach ) return g ( i , j ) = ( g ( i , j ) - ddot ( j - 1 , g ( i , 1 ), lg , e ( 1 , j ), 1 )) / e ( j , j ) end do h ( i ) = h ( i ) - ddot ( n , g ( i , 1 ), lg , f , 1 ) end do !  solve least distance problem call ldp ( g , lg , mg , n , h , x , xnorm , w , jw , mode ) if ( mode == 1 ) then !  solution of original problem call daxpy ( n , one , f , 1 , x , 1 ) do i = n , 1 , - 1 j = min ( i + 1 , n ) x ( i ) = ( x ( i ) - ddot ( n - i , e ( i , j ), le , x ( j ), 1 )) / e ( i , i ) end do j = min ( n + 1 , me ) t = dnrm2 ( me - n , f ( j ), 1 ) xnorm = sqrt ( xnorm * xnorm + t * t ) end if end subroutine lsi !******************************************************************************* !******************************************************************************* !> !  Least distance programming routine. !  Minimize  \\frac{1}{2} \\mathbf{x}&#94;T \\mathbf{x}   subject to !   \\mathbf{G} \\mathbf{x} \\ge \\mathbf{h} . ! !  The declared dimension of `w` must be at least `(n+1)*(m+2)+2*m`: !```` !       first (n+1)*m locs of w = matrix e for problem nnls. !       next      n+1 locs of w = vector f for problem nnls. !       next      n+1 locs of w = vector z for problem nnls. !       next        m locs of w = vector y for problem nnls. !       next        m locs of w = vector wdual for problem nnls. !```` ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. ! !@note The 1995 version of this routine may have some sort of problem. !      Using a refactored version of the original routine. subroutine ldp ( g , mg , m , n , h , x , xnorm , w , index , mode ) implicit none integer , intent ( in ) :: mg integer , intent ( in ) :: m integer , intent ( in ) :: n real ( wp ), dimension ( mg , n ), intent ( in ) :: g !! on entry `g` stores the `m` by `n` matrix of !! linear inequality constraints. `g` has first !! dimensioning parameter `mg` real ( wp ), dimension ( m ), intent ( in ) :: h !! the right side of the inequality system. real ( wp ), dimension ( n ), intent ( out ) :: x !! solution vector `x` if `mode=1`. real ( wp ), dimension ( * ), intent ( inout ) :: w !! `w` is a one dimensional working space, the length !! of which should be at least `(m+2)*(n+1) + 2*m`. !! on exit `w` stores the lagrange multipliers !! associated with the constraints. !! at the solution of problem `ldp`. integer , dimension ( m ), intent ( inout ) :: index !! integer working space real ( wp ), intent ( out ) :: xnorm !! euclidian norm of the solution vector !! if computation is successful integer , intent ( out ) :: mode !! success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<=0`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible. integer :: i , iw , iwdual , iy , iz , j , jf , n1 real ( wp ) :: fac , rnorm if ( n <= 0 ) then ! error return. mode = 2 else ! state dual problem mode = 1 x = zero xnorm = zero if ( m /= 0 ) then iw = 0 do j = 1 , m do i = 1 , n iw = iw + 1 w ( iw ) = g ( j , i ) end do iw = iw + 1 w ( iw ) = h ( j ) end do jf = iw + 1 do i = 1 , n iw = iw + 1 w ( iw ) = zero end do w ( iw + 1 ) = one n1 = n + 1 iz = iw + 2 iy = iz + n1 iwdual = iy + m ! solve dual problem call nnls ( w , n1 , n1 , m , w ( jf ), w ( iy ), rnorm , w ( iwdual ), w ( iz ), index , mode ) if ( mode == 1 ) then mode = 4 if ( rnorm > zero ) then !  compute solution of primal problem fac = one - ddot ( m , h , 1 , w ( iy ), 1 ) if ( diff ( one + fac , one ) > zero ) then mode = 1 fac = one / fac do j = 1 , n x ( j ) = fac * ddot ( m , g ( 1 , j ), 1 , w ( iy ), 1 ) end do xnorm = dnrm2 ( n , x , 1 ) ! compute lagrange multipliers for primal problem w ( 1 ) = zero call dcopy ( m , w ( 1 ), 0 , w , 1 ) call daxpy ( m , fac , w ( iy ), 1 , w , 1 ) end if end if end if end if end if end subroutine ldp !******************************************************************************* !******************************************************************************* !> !  Replaced statement function in the original code. !  Returns  d = u - v . pure elemental function diff ( u , v ) result ( d ) implicit none real ( wp ), intent ( in ) :: u real ( wp ), intent ( in ) :: v real ( wp ) :: d d = u - v end function diff !******************************************************************************* !******************************************************************************* !> !  Nonnegative least squares algorithm. ! !  Given an m by n matrix, \\mathbf{A}, and an m-vector, \\mathbf{b}, !  compute an n-vector, \\mathbf{x}, that solves the least squares problem: ! !   \\mathbf{A} \\mathbf{x} = \\mathbf{b} subject to  \\mathbf{x} \\ge 0  ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. subroutine nnls ( a , mda , m , n , b , x , rnorm , w , zz , index , mode ) implicit none integer , intent ( in ) :: mda !! first dimensioning parameter for the array `a`. integer , intent ( in ) :: n real ( wp ), dimension ( mda , n ), intent ( inout ) :: a !! on entry, contains the `m` by `n` !! matrix, `a`. on exit, contains !! the product matrix, `q*a`, where `q` is an !! `m` by `m` orthogonal matrix generated implicitly by !! this subroutine. integer , intent ( in ) :: m real ( wp ), dimension ( m ), intent ( inout ) :: b !! on entry, contains the m-vector `b`. on exit, contains `q*b`. real ( wp ), dimension ( n ), intent ( out ) :: x !! the solution vector. real ( wp ), intent ( out ) :: rnorm !! euclidean norm of the residual vector. real ( wp ), dimension ( n ), intent ( inout ) :: w !! array of working space.  on exit `w` will contain !! the dual solution vector. `w` will satisfy `w(i) = 0` !! for all `i` in set `p` and `w(i) <= 0` for all `i` in set `z`. real ( wp ), dimension ( m ), intent ( inout ) :: zz !! an m-array of working space. integer , dimension ( n ), intent ( out ) :: index !! an integer working array. !! on exit the contents of this array define the sets !! `p` and `z` as follows: !! !! * `index(1:nsetp) = set p`. !! * `index(iz1:iz2) = set z`. !! !! where: `iz1 = nsetp + 1 = npp1`, `iz2 = n` integer , intent ( out ) :: mode !! this is a success-failure flag with the following meanings: !! !! * ***1*** the solution has been computed successfully. !! * ***2*** the dimensions of the problem are bad. either `m<=0` or `n<=0`. !! * ***3*** iteration count exceeded. more than `3*n` iterations. integer :: i , ii , ip , iter , itmax , iz , iz1 , iz2 , izmax , j , jj , jz , l , npp1 , nsetp , rtnkey real ( wp ) :: alpha , asave , cc , sm , ss , t , temp , unorm , up , wmax , ztest real ( wp ), dimension ( 1 ) :: dummy real ( wp ), parameter :: factor = 0.01_wp mode = 1 if ( m <= 0 . or . n <= 0 ) then mode = 2 return end if iter = 0 itmax = 3 * n ! initialize the arrays index() and x(). do i = 1 , n x ( i ) = zero index ( i ) = i end do iz2 = n iz1 = 1 nsetp = 0 npp1 = 1 ! ******  main loop begins here  ****** ! quit if all coefficients are already in the solution. ! or if m cols of a have been triangularized. 100 if ( iz1 <= iz2 . and . nsetp < m ) then ! compute components of the dual (negative gradient) vector w(). do iz = iz1 , iz2 j = index ( iz ) sm = zero do l = npp1 , m sm = sm + a ( l , j ) * b ( l ) end do w ( j ) = sm end do ! find largest positive w(j). 150 wmax = zero do iz = iz1 , iz2 j = index ( iz ) if ( w ( j ) > wmax ) then wmax = w ( j ) izmax = iz end if end do ! if wmax <= 0. go to termination. ! this indicates satisfaction of the kuhn-tucker conditions. if ( wmax > zero ) then iz = izmax j = index ( iz ) ! the sign of w(j) is ok for j to be moved to set p. ! begin the transformation and check new diagonal element to avoid ! near linear dependence. asave = a ( npp1 , j ) call h12 ( 1 , npp1 , npp1 + 1 , m , a ( 1 , j ), 1 , up , dummy , 1 , 1 , 0 ) unorm = zero if ( nsetp /= 0 ) then do l = 1 , nsetp unorm = unorm + a ( l , j ) ** 2 end do end if unorm = sqrt ( unorm ) if ( diff ( unorm + abs ( a ( npp1 , j )) * factor , unorm ) > zero ) then ! col j is sufficiently independent.  copy b into zz, update zz ! and solve for ztest ( = proposed new value for x(j) ). do l = 1 , m zz ( l ) = b ( l ) end do call h12 ( 2 , npp1 , npp1 + 1 , m , a ( 1 , j ), 1 , up , zz , 1 , 1 , 1 ) ztest = zz ( npp1 ) / a ( npp1 , j ) ! see if ztest is positive if ( ztest > zero ) then ! the index j=index(iz) has been selected to be moved from ! set z to set p. update b, update indices, apply householder ! transformations to cols in new set z, zero subdiagonal elts in ! col j, set w(j)=0. do l = 1 , m b ( l ) = zz ( l ) end do index ( iz ) = index ( iz1 ) index ( iz1 ) = j iz1 = iz1 + 1 nsetp = npp1 npp1 = npp1 + 1 if ( iz1 <= iz2 ) then do jz = iz1 , iz2 jj = index ( jz ) call h12 ( 2 , nsetp , npp1 , m , a ( 1 , j ), 1 , up , a ( 1 , jj ), 1 , mda , 1 ) end do end if if ( nsetp /= m ) then do l = npp1 , m a ( l , j ) = zero end do end if w ( j ) = zero ! solve the triangular system. ! store the solution temporarily in zz(). rtnkey = 1 goto 300 end if end if ! reject j as a candidate to be moved from set z to set p. ! restore a(npp1,j), set w(j)=0., and loop back to test dual ! coeffs again. a ( npp1 , j ) = asave w ( j ) = zero goto 150 end if end if ! ******  end of main loop  ****** ! come to here for termination. ! compute the norm of the final residual vector. 200 sm = zero if ( npp1 <= m ) then do i = npp1 , m sm = sm + b ( i ) ** 2 end do else do j = 1 , n w ( j ) = zero end do end if rnorm = sqrt ( sm ) return ! the following block of code is used as an internal subroutine ! to solve the triangular system, putting the solution in zz(). 300 do l = 1 , nsetp ip = nsetp + 1 - l if ( l /= 1 ) then do ii = 1 , ip zz ( ii ) = zz ( ii ) - a ( ii , jj ) * zz ( ip + 1 ) end do end if jj = index ( ip ) zz ( ip ) = zz ( ip ) / a ( ip , jj ) end do !   if ( rtnkey==1 ) then    !.....original !       !continue !   else if ( rtnkey/=2 ) then !       return !   end if if ( rtnkey /= 1 . and . rtnkey /= 2 ) return !......replaced with ! ******  secondary loop begins here ****** ! iteration counter. iter = iter + 1 if ( iter > itmax ) then mode = 3 !write (*,'(/a)') ' nnls quitting on iteration count.' goto 200 end if ! see if all new constrained coeffs are feasible. ! if not compute alpha. alpha = two do ip = 1 , nsetp l = index ( ip ) if ( zz ( ip ) <= zero ) then t = - x ( l ) / ( zz ( ip ) - x ( l )) if ( alpha > t ) then alpha = t jj = ip end if end if end do ! if all new constrained coeffs are feasible then alpha will ! still = 2.    if so exit from secondary loop to main loop. if ( alpha == two ) then ! ******  end of secondary loop  ****** do ip = 1 , nsetp i = index ( ip ) x ( i ) = zz ( ip ) end do ! all new coeffs are positive.  loop back to beginning. goto 100 else ! otherwise use alpha which will be between 0. and 1. to ! interpolate between the old x and the new zz. do ip = 1 , nsetp l = index ( ip ) x ( l ) = x ( l ) + alpha * ( zz ( ip ) - x ( l )) end do ! modify a and b and the index arrays to move coefficient i ! from set p to set z. i = index ( jj ) 350 x ( i ) = zero if ( jj /= nsetp ) then jj = jj + 1 do j = jj , nsetp ii = index ( j ) index ( j - 1 ) = ii call g1 ( a ( j - 1 , ii ), a ( j , ii ), cc , ss , a ( j - 1 , ii )) a ( j , ii ) = zero do l = 1 , n if ( l /= ii ) then ! apply procedure g2 (cc,ss,a(j-1,l),a(j,l)) temp = a ( j - 1 , l ) a ( j - 1 , l ) = cc * temp + ss * a ( j , l ) a ( j , l ) = - ss * temp + cc * a ( j , l ) end if end do ! apply procedure g2 (cc,ss,b(j-1),b(j)) temp = b ( j - 1 ) b ( j - 1 ) = cc * temp + ss * b ( j ) b ( j ) = - ss * temp + cc * b ( j ) end do end if npp1 = nsetp nsetp = nsetp - 1 iz1 = iz1 - 1 index ( iz1 ) = i ! see if the remaining coeffs in set p are feasible.  they should ! be because of the way alpha was determined. ! if any are infeasible it is due to round-off error.  any ! that are nonpositive will be set to zero ! and moved from set p to set z. do jj = 1 , nsetp i = index ( jj ) if ( x ( i ) <= zero ) goto 350 end do ! copy b( ) into zz( ).  then solve again and loop back. do i = 1 , m zz ( i ) = b ( i ) end do rtnkey = 2 goto 300 end if end subroutine nnls !******************************************************************************* !******************************************************************************* !> !  Rank-deficient least squares algorithm using !  householder forward triangulation with column interchanges. ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. subroutine hfti ( a , mda , m , n , b , mdb , nb , tau , krank , rnorm , h , g , ip ) implicit none integer , intent ( in ) :: mda !! the first dimensioning parameter of matrix `a` (mda >= m). integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: mdb !! first dimensioning parameter of matrix `b` (mdb>=max(m,n)) integer , intent ( in ) :: nb real ( wp ), dimension ( mda , n ), intent ( inout ) :: a !! the array `a` initially contains the  m \\times n  matrix \\mathbf{A} !! of the least squares problem  \\mathbf{A} \\mathbf{x} = \\mathbf{b} . !! either `m >= n` or `m < n` is permitted. !! there is no restriction on the rank of `a`. !! the matrix `a` will be modified by the subroutine. real ( wp ), intent ( in ) :: tau !! absolute tolerance parameter for pseudorank !! determination, provided by the user. integer , intent ( out ) :: krank !! pseudorank of `a`, set by the subroutine. real ( wp ), dimension ( nb ), intent ( out ) :: rnorm !! on exit, `rnorm(j)` will contain the euclidian !! norm of the residual vector for the problem !! defined by the `j-th` column vector of the array `b`. real ( wp ), dimension ( n ), intent ( inout ) :: h !! array of working space real ( wp ), dimension ( n ), intent ( inout ) :: g !! array of working space integer , dimension ( n ), intent ( inout ) :: ip !! integer array of working space !! recording permutation indices of column vectors real ( wp ), dimension ( mdb , nb ), intent ( inout ) :: b !! if `nb = 0` the subroutine will make no reference !! to the array `b`. if `nb > 0` the array `b` must !! initially contain the `m x nb` matrix `b` of the !! the least squares problem `ax = b` and on return !! the array `b` will contain the `n x nb` solution `x`. integer :: i , ii , ip1 , j , jb , jj , k , kp1 , l , ldiag , lmax real ( wp ) :: hmax , sm , tmp logical :: need_lmax real ( wp ), parameter :: factor = 0.001_wp k = 0 ldiag = min ( m , n ) if ( ldiag <= 0 ) then ! the solution vectors, x, are now ! in the first  n  rows of the array b(,). krank = k return else do j = 1 , ldiag need_lmax = . true . if ( j /= 1 ) then ! update squared column lengths and find lmax lmax = j do l = j , n h ( l ) = h ( l ) - a ( j - 1 , l ) ** 2 if ( h ( l ) > h ( lmax ) ) lmax = l end do if ( diff ( hmax + factor * h ( lmax ), hmax ) > 0 ) need_lmax = . false . end if if ( need_lmax ) then ! compute squared column lengths and find lmax lmax = j do l = j , n h ( l ) = 0. do i = j , m h ( l ) = h ( l ) + a ( i , l ) ** 2 end do if ( h ( l ) > h ( lmax ) ) lmax = l end do hmax = h ( lmax ) end if ! lmax has been determined ! do column interchanges if needed. ip ( j ) = lmax if ( ip ( j ) /= j ) then do i = 1 , m tmp = a ( i , j ) a ( i , j ) = a ( i , lmax ) a ( i , lmax ) = tmp end do h ( lmax ) = h ( j ) end if ! compute the j-th transformation and apply it to a and b. call h12 ( 1 , j , j + 1 , m , a ( 1 , j ), 1 , h ( j ), a ( 1 , j + 1 ), 1 , mda , n - j ) call h12 ( 2 , j , j + 1 , m , a ( 1 , j ), 1 , h ( j ), b , 1 , mdb , nb ) end do ! determine the pseudorank, k, using the tolerance, tau. do j = 1 , ldiag if ( abs ( a ( j , j )) <= tau ) exit end do k = j - 1 kp1 = j end if ! compute the norms of the residual vectors. if ( nb > 0 ) then do jb = 1 , nb tmp = zero if ( kp1 <= m ) then do i = kp1 , m tmp = tmp + b ( i , jb ) ** 2 end do end if rnorm ( jb ) = sqrt ( tmp ) end do end if ! special for pseudorank = 0 if ( k > 0 ) then ! if the pseudorank is less than n compute householder ! decomposition of first k rows. if ( k /= n ) then do ii = 1 , k i = kp1 - ii call h12 ( 1 , i , kp1 , n , a ( i , 1 ), mda , g ( i ), a , mda , 1 , i - 1 ) end do end if if ( nb > 0 ) then do jb = 1 , nb ! solve the k by k triangular system. do l = 1 , k sm = zero i = kp1 - l if ( i /= k ) then ip1 = i + 1 do j = ip1 , k sm = sm + a ( i , j ) * b ( j , jb ) end do end if b ( i , jb ) = ( b ( i , jb ) - sm ) / a ( i , i ) end do ! complete computation of solution vector. if ( k /= n ) then do j = kp1 , n b ( j , jb ) = zero end do do i = 1 , k call h12 ( 2 , i , kp1 , n , a ( i , 1 ), mda , g ( i ), b ( 1 , jb ), 1 , mdb , 1 ) end do end if ! re-order the solution vector to compensate for the ! column interchanges. do jj = 1 , ldiag j = ldiag + 1 - jj if ( ip ( j ) /= j ) then l = ip ( j ) tmp = b ( l , jb ) b ( l , jb ) = b ( j , jb ) b ( j , jb ) = tmp end if end do end do end if else if ( nb > 0 ) then do jb = 1 , nb do i = 1 , n b ( i , jb ) = zero end do end do end if krank = k end subroutine hfti !******************************************************************************* !******************************************************************************* !> !  Construction and/or application of a single !  householder transformation  Q = I + u(u&#94;t)/b . ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. subroutine h12 ( mode , lpivot , l1 , m , u , iue , up , c , ice , icv , ncv ) implicit none integer , intent ( in ) :: mode !! `1` or `2` -- selects algorithm ***h1*** to construct and apply a !! householder transformation, or algorithm ***h2*** to apply a !! previously constructed transformation. integer , intent ( in ) :: lpivot !! the index of the pivot element integer , intent ( in ) :: l1 !! if `l1 <= m` the transformation will be constructed to !! zero elements indexed from `l1` through `m`. !! if `l1 > m` the subroutine does an identity transformation. integer , intent ( in ) :: m !! see `li`. integer , intent ( in ) :: iue !! see `u`. real ( wp ), dimension ( iue , * ), intent ( inout ) :: u !! on entry with `mode = 1`, `u` contains the pivot !! vector.  `iue` is the storage increment between elements. !! on exit when `mode = 1`, `u` and `up` contain quantities !! defining the vector `u` of the householder transformation. !! on entry with `mode = 2`, `u` and `up` should contain !! quantities previously computed with `mode = 1`.  these will !! not be modified during the entry with `mode = 2`. !! `dimension[u(iue,m)]` real ( wp ), intent ( inout ) :: up !! see `u`. real ( wp ), dimension ( * ), intent ( inout ) :: c !! on entry with `mode = 1 or 2`, `c` contains a matrix which !! will be regarded as a set of vectors to which the !! householder transformation is to be applied. !! on exit `c` contains the set of transformed vectors. integer , intent ( in ) :: ice !! storage increment between elements of vectors in `c`. integer , intent ( in ) :: icv !! storage increment between vectors in `c`. integer , intent ( in ) :: ncv !! number of vectors in `c` to be transformed. if `ncv <= 0` !! no operations will be done on `c`. integer :: i , i2 , i3 , i4 , incr , j real ( wp ) :: b , cl , clinv , sm if ( 0 >= lpivot . or . lpivot >= l1 . or . l1 > m ) return cl = abs ( u ( 1 , lpivot )) if ( mode /= 2 ) then ! construct the transformation. do j = l1 , m cl = max ( abs ( u ( 1 , j )), cl ) end do if ( cl <= 0 ) return clinv = one / cl sm = ( u ( 1 , lpivot ) * clinv ) ** 2 do j = l1 , m sm = sm + ( u ( 1 , j ) * clinv ) ** 2 end do cl = cl * sqrt ( sm ) if ( u ( 1 , lpivot ) > 0 ) cl = - cl up = u ( 1 , lpivot ) - cl u ( 1 , lpivot ) = cl else if ( cl <= 0 ) then return end if if ( ncv > 0 ) then ! apply the transformation i+u*(u**t)/b to c. b = up * u ( 1 , lpivot ) ! b must be nonpositive here. if ( b < 0 ) then b = one / b i2 = 1 - icv + ice * ( lpivot - 1 ) incr = ice * ( l1 - lpivot ) do j = 1 , ncv i2 = i2 + icv i3 = i2 + incr i4 = i3 sm = c ( i2 ) * up do i = l1 , m sm = sm + c ( i3 ) * u ( 1 , i ) i3 = i3 + ice end do if ( sm /= 0 ) then sm = sm * b c ( i2 ) = c ( i2 ) + sm * up do i = l1 , m c ( i4 ) = c ( i4 ) + sm * u ( 1 , i ) i4 = i4 + ice end do end if end do end if end if end subroutine h12 !******************************************************************************* !******************************************************************************* !> !  Compute orthogonal rotation matrix. ! !  Compute matrix  \\left[ \\begin{array}{cc} c & s \\\\ -s & c \\end{array} \\right]  !  so that  !  \\left[ \\begin{array}{cc} c & s \\\\ -s & c \\end{array} \\right] !  \\left[ \\begin{array}{c} a \\\\ b \\end{array} \\right]  = !  \\left[ \\begin{array}{c} \\sqrt{a&#94;2+b&#94;2} \\\\ 0 \\end{array} \\right] !   ! !  Compute  \\sigma = \\sqrt{a&#94;2+b&#94;2}  ! !   \\sigma  is computed last to allow for the possibility that !  `sig` may be in the same location as `a` or `b`. ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. subroutine g1 ( a , b , c , s , sig ) implicit none real ( wp ) :: a real ( wp ) :: b real ( wp ) :: sig real ( wp ), intent ( out ) :: c real ( wp ), intent ( out ) :: s real ( wp ) :: xr , yr if ( abs ( a ) > abs ( b ) ) then xr = b / a yr = sqrt ( one + xr ** 2 ) c = sign ( one / yr , a ) s = c * xr sig = abs ( a ) * yr else if ( b /= zero ) then xr = a / b yr = sqrt ( one + xr ** 2 ) s = sign ( one / yr , b ) c = s * xr sig = abs ( b ) * yr else sig = zero c = zero s = one end if end if end subroutine g1 !******************************************************************************* !******************************************************************************* !> !  LDL&#94;T - rank-one - update ! !### Purpose: ! !  Updates the LDL&#94;T factors of matrix A !  by rank-one matrix \\sigma z z&#94;T . ! !### Reference !  * R. Fletcher, M.J.D. Powell, !    \"[On the modification of LDL' factorization](http://www.ams.org/journals/mcom/1974-28-128/S0025-5718-1974-0359297-1/S0025-5718-1974-0359297-1.pdf)\". !    Mathematics of Computation Vol. 28, No. 128, p. 1067-1087, October 1974. ! !### History !  * D. Kraft, DFVLR - institut fuer dynamik der flugsysteme !    d-8031  oberpfaffenhofen !  * Status: 15. january 1980 subroutine ldl ( n , a , z , sigma , w ) implicit none integer , intent ( in ) :: n !! order of the coefficient matrix `a` real ( wp ), intent ( in ) :: sigma !! scalar factor by which the modifying dyade z z&#94;T is multiplied. real ( wp ), dimension ( * ), intent ( inout ) :: a !! ***In:*** positive definite matrix of dimension `n`; !! only the lower triangle is used and is stored column by !! column as one dimensional array of dimension `n*(n+1)/2`. !! !! ***Out:*** updated LDL&#94;T factors real ( wp ), dimension ( * ), intent ( inout ) :: w !! working array of dimension `n` (used only if  \\sigma \\lt 0  ). real ( wp ), dimension ( * ), intent ( inout ) :: z !! vector of dimension `n` of updating elements. integer :: i , ij , j real ( wp ) :: t , v , u , tp , beta , alpha , delta , gamma if ( sigma /= zero ) then ij = 1 t = one / sigma if ( sigma <= zero ) then ! prepare negative update do i = 1 , n w ( i ) = z ( i ) end do do i = 1 , n v = w ( i ) t = t + v * v / a ( ij ) do j = i + 1 , n ij = ij + 1 w ( j ) = w ( j ) - v * a ( ij ) end do ij = ij + 1 end do if ( t >= zero ) t = epmach / sigma do i = 1 , n j = n + 1 - i ij = ij - i u = w ( j ) w ( j ) = t t = t - u * u / a ( ij ) end do end if ! here updating begins do i = 1 , n v = z ( i ) delta = v / a ( ij ) if ( sigma < zero ) tp = w ( i ) if ( sigma > zero ) tp = t + delta * v alpha = tp / t a ( ij ) = alpha * a ( ij ) if ( i == n ) return beta = delta / tp if ( alpha > four ) then gamma = t / tp do j = i + 1 , n ij = ij + 1 u = a ( ij ) a ( ij ) = gamma * u + beta * z ( j ) z ( j ) = z ( j ) - v * u end do else do j = i + 1 , n ij = ij + 1 z ( j ) = z ( j ) - v * a ( ij ) a ( ij ) = a ( ij ) + beta * z ( j ) end do end if ij = ij + 1 t = tp end do end if end subroutine ldl !******************************************************************************* !******************************************************************************* !> !  Linesearch without derivatives (used by [[slsqp]] if `linesearch_mode=2`). !  Returns the abscissa approximating the point where `f` attains a minimum. ! !### purpose: ! !  to find the argument linmin where the function `f` takes it's minimum !  on the interval `ax`, `bx`. It uses a combination of golden section !  and successive quadratic interpolation. ! !### Reference ! !  This function subprogram is a slightly modified version of the !  ALGOL 60 procedure `localmin` given in R.P. Brent: !  \"[Algorithms for minimization without derivatives](https://maths-people.anu.edu.au/~brent/pub/pub011.html)\", !  Prentice-Hall (1973). ! !### History ! !  * Kraft, D., DFVLR - institut fuer dynamik der flugsysteme !    d-8031  oberpfaffenhofen !  * status: 31. august 1984 !  * Jacob Williams, Jan 2016, Refactored into modern Fortran. !    Added saved variables as `inout`s to make the routine thread-safe. real ( wp ) function linmin ( mode , ax , bx , f , tol ,& a , b , d , e , p , q , r , u , v ,& w , x , m , fu , fv , fw , fx , tol1 , tol2 ) implicit none integer , intent ( inout ) :: mode !! controls reverse communication !! must be set to 0 initially, returns with intermediate !! values 1 and 2 which must not be changed by the user, !! ends with convergence with value 3. real ( wp ) :: f !! function value at `linmin` which is to be brought in by !! reverse communication controlled by `mode` real ( wp ), intent ( in ) :: tol !! desired length of interval of uncertainty of final result real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( inout ) :: a , b , d , e , p , q , r , u , v , w , x , m , fu , fv , fw , fx , tol1 , tol2 real ( wp ), parameter :: c = ( 3.0_wp - sqrt ( 5.0_wp )) / 2.0_wp !! golden section ratio = `0.381966011` real ( wp ), parameter :: eps = sqrt ( epsilon ( 1.0_wp )) !! square - root of machine precision select case ( mode ) case ( 1 ) ! main loop starts here fx = f fv = fx fw = fv case ( 2 ) fu = f ! update a, b, v, w, and x if ( fu > fx ) then if ( u < x ) a = u if ( u >= x ) b = u if ( fu <= fw . or . w == x ) then v = w fv = fw w = u fw = fu else if ( fu <= fv . or . v == x . or . v == w ) then v = u fv = fu end if else if ( u >= x ) a = x if ( u < x ) b = x v = w fv = fw w = x fw = fx x = u fx = fu end if case default ! initialization a = ax b = bx e = zero v = a + c * ( b - a ) w = v x = w linmin = x mode = 1 return end select m = 0.5_wp * ( a + b ) tol1 = eps * abs ( x ) + tol tol2 = tol1 + tol1 ! test convergence if ( abs ( x - m ) <= tol2 - 0.5_wp * ( b - a ) ) then ! end of main loop linmin = x mode = 3 else r = zero q = r p = q if ( abs ( e ) > tol1 ) then ! fit parabola r = ( x - w ) * ( fx - fv ) q = ( x - v ) * ( fx - fw ) p = ( x - v ) * q - ( x - w ) * r q = q - r q = q + q if ( q > zero ) p = - p if ( q < zero ) q = - q r = e e = d end if ! is parabola acceptable if ( abs ( p ) >= 0.5_wp * abs ( q * r ) . or . p <= q * ( a - x ) . or . p >= q * ( b - x ) ) then ! golden section step if ( x >= m ) e = a - x if ( x < m ) e = b - x d = c * e else ! parabolic interpolation step d = p / q ! f must not be evaluated too close to a or b if ( u - a < tol2 ) d = sign ( tol1 , m - x ) if ( b - u < tol2 ) d = sign ( tol1 , m - x ) end if ! f must not be evaluated too close to x if ( abs ( d ) < tol1 ) d = sign ( tol1 , d ) u = x + d linmin = u mode = 2 end if end function linmin !******************************************************************************* !******************************************************************************* !> !  enforce the bound constraints on x. subroutine enforce_bounds ( x , xl , xu ) implicit none real ( wp ), dimension (:), intent ( inout ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( in ) :: xl !! lower bounds (must be same dimension as `x`) real ( wp ), dimension (:), intent ( in ) :: xu !! upper bounds (must be same dimension as `x`) where ( x < xl ) x = xl elsewhere ( x > xu ) x = xu end where end subroutine enforce_bounds !******************************************************************************* !******************************************************************************* !> !  Destructor for [[slsqpb_data]] type. subroutine destroy_slsqpb_data ( me ) implicit none class ( slsqpb_data ), intent ( out ) :: me end subroutine destroy_slsqpb_data !******************************************************************************* !******************************************************************************* !> !  Destructor for [[linmin_data]] type. subroutine destroy_linmin_data ( me ) implicit none class ( linmin_data ), intent ( out ) :: me end subroutine destroy_linmin_data !******************************************************************************* !******************************************************************************* end module slsqp_core !*******************************************************************************","tags":"","loc":"sourcefile/slsqp_core.f90.html","title":"slsqp_core.f90 – slsqp"},{"text":"This File Depends On sourcefile~~slsqp_test_2.f90~~EfferentGraph sourcefile~slsqp_test_2.f90 slsqp_test_2.f90 sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_test_2.f90 sourcefile~slsqp_kinds.f90 slsqp_kinds.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_test_2.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_module.f90 sourcefile~slsqp_support.f90 slsqp_support.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_module.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs slsqp_test_2 Source Code slsqp_test_2.f90 Source Code !******************************************************************************* !> author: Jacob Williams ! !  Test for the [[slsqp_module]]. program slsqp_test_2 use slsqp_module use slsqp_kinds implicit none integer , parameter :: n = 3 !! number of optimization variables integer , parameter :: m = 2 !! total number of constraints integer , parameter :: meq = 1 !! number of equality constraints integer , parameter :: max_iter = 100 !! maximum number of allowed iterations real ( wp ), dimension ( n ), parameter :: xl = [ - 1 0.0_wp , - 1 0.0_wp , - 1 0.0_wp ] !! lower bounds real ( wp ), dimension ( n ), parameter :: xu = [ 1 0.0_wp , 1 0.0_wp , 1 0.0_wp ] !! upper bounds real ( wp ), parameter :: acc = 1.0e-7_wp !! tolerance integer , parameter :: linesearch_mode = 1 !! use inexact linesearch. type ( slsqp_solver ) :: solver !! instantiate an slsqp solver real ( wp ), dimension ( n ) :: x !! optimization variable vector integer :: istat !! for solver status check logical :: status_ok !! for initialization status check integer :: iterations !! number of iterations by the solver x = [ 1.0_wp , 2.0_wp , 3.0_wp ] ! initial guess call solver % initialize ( n , m , meq , max_iter , acc , test_func , test_grad ,& xl , xu , linesearch_mode = linesearch_mode , status_ok = status_ok ,& report = report_iteration ,& alphamin = 0.1_wp , alphamax = 0.5_wp ) !to limit search steps if ( status_ok ) then call solver % optimize ( x , istat , iterations ) write ( * , * ) '' write ( * , * ) 'solution   :' , x write ( * , * ) 'istat      :' , istat write ( * , * ) 'iterations :' , iterations write ( * , * ) '' else error stop 'error calling slsqp.' end if ! Solution is: x = [1,1,1], f = 3 contains subroutine test_func ( me , x , f , c ) !!  Compute the objective function and constraints !! !!  Minimize: !! !!   *  f = x_1&#94;2 + x_2&#94;2 + x_3  !! !!  Subject to: !! !!   *  c_1 = x_1 x_2 - x_3 = 0  !!   *  c_2 = x_3 - 1 \\ge 0  implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( out ) :: f !! value of the objective function real ( wp ), dimension (:), intent ( out ) :: c !! the constraint vector `dimension(m)`, !! equality constraints (if any) first. f = x ( 1 ) ** 2 + x ( 2 ) ** 2 + x ( 3 ) !objective function c ( 1 ) = x ( 1 ) * x ( 2 ) - x ( 3 ) !equality constraint (==0) c ( 2 ) = x ( 3 ) - 1.0_wp !inequality constraint (>=0) end subroutine test_func subroutine test_grad ( me , x , g , a ) !! compute the gradients. implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( out ) :: g !! objective function partials w.r.t x `dimension(n)` real ( wp ), dimension (:,:), intent ( out ) :: a !! gradient matrix of constraints w.r.t. x `dimension(m,n)` g ( 1 ) = 2.0_wp * x ( 1 ) g ( 2 ) = 2.0_wp * x ( 2 ) g ( 3 ) = 1.0_wp a ( 1 , 1 ) = x ( 2 ) a ( 1 , 2 ) = x ( 1 ) a ( 1 , 3 ) = - 1.0_wp a ( 2 , 1 ) = 0.0_wp a ( 2 , 2 ) = 0.0_wp a ( 2 , 3 ) = 1.0_wp end subroutine test_grad subroutine report_iteration ( me , iter , x , f , c ) !! report an iteration (print to the console). use , intrinsic :: iso_fortran_env , only : output_unit implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: iter real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), intent ( in ) :: f real ( wp ), dimension (:), intent ( in ) :: c !write a header: if ( iter == 0 ) then write ( output_unit , '(*(A20,1X))' ) 'iteration' , & 'x(1)' , 'x(2)' , 'x(3)' , & 'f(1)' , 'c(1)' , 'c(2)' end if !write the iteration data: write ( output_unit , '(I20,1X,(*(F20.16,1X)))' ) iter , x , f , c end subroutine report_iteration end program slsqp_test_2 !*******************************************************************************","tags":"","loc":"sourcefile/slsqp_test_2.f90.html","title":"slsqp_test_2.f90 – slsqp"},{"text":"This File Depends On sourcefile~~slsqp_test.f90~~EfferentGraph sourcefile~slsqp_test.f90 slsqp_test.f90 sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_test.f90 sourcefile~slsqp_kinds.f90 slsqp_kinds.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_test.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_module.f90 sourcefile~slsqp_support.f90 slsqp_support.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_kinds.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_module.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_module.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs slsqp_test Source Code slsqp_test.f90 Source Code !******************************************************************************* !> author: Jacob Williams ! !  Test for the [[slsqp_module]]. program slsqp_test use slsqp_module use slsqp_kinds implicit none integer , parameter :: n = 2 !! number of optimization variables integer , parameter :: m = 1 !! total number of constraints integer , parameter :: meq = 0 !! number of equality constraints integer , parameter :: max_iter = 100 !! maximum number of allowed iterations real ( wp ), dimension ( n ), parameter :: xl = [ - 1.0_wp , - 1.0_wp ] !! lower bounds real ( wp ), dimension ( n ), parameter :: xu = [ 1.0_wp , 1.0_wp ] !! upper bounds real ( wp ), parameter :: acc = 1.0e-8_wp !! tolerance integer , parameter :: linesearch_mode = 1 !! use inexact linesearch. type ( slsqp_solver ) :: solver !! instantiate an slsqp solver real ( wp ), dimension ( n ) :: x !! optimization variable vector integer :: istat !! for solver status check logical :: status_ok !! for initialization status check integer :: iterations !! number of iterations by the solver x = [ 0.1_wp , 0.1_wp ] !initial guess call solver % initialize ( n , m , meq , max_iter , acc , rosenbrock_func , rosenbrock_grad ,& xl , xu , linesearch_mode = linesearch_mode , status_ok = status_ok ,& report = report_iteration ) !alphamin=0.1_wp, alphamax=0.5_wp) !to limit search steps if ( status_ok ) then call solver % optimize ( x , istat , iterations ) write ( * , * ) '' write ( * , * ) 'solution   :' , x write ( * , * ) 'istat      :' , istat write ( * , * ) 'iterations :' , iterations write ( * , * ) '' else error stop 'error calling slsqp.' end if !solution:  x1 = 0.78641515097183889 !           x2 = 0.61769831659541152 !           f  = 4.5674808719160388E-002 !           c  = 2.8654301154062978E-012 contains subroutine rosenbrock_func ( me , x , f , c ) !! Rosenbrock function !! !! Minimize the Rosenbrock function:  f(x) = 100 (x_2 - x_1)&#94;2 + (1 - x_1)&#94;2 , !! subject to the inequality constraint:  x_1&#94;2 + x_2&#94;2 \\le 1 . !! !! see: http://www.mathworks.com/help/optim/ug/example-nonlinear-constrained-minimization.html implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( out ) :: f !! value of the objective function real ( wp ), dimension (:), intent ( out ) :: c !! the constraint vector `dimension(m)`, !! equality constraints (if any) first. f = 10 0.0_wp * ( x ( 2 ) - x ( 1 ) ** 2 ) ** 2 + ( 1.0_wp - x ( 1 )) ** 2 !objective function c ( 1 ) = 1.0_wp - x ( 1 ) ** 2 - x ( 2 ) ** 2 !equality constraint (>=0) end subroutine rosenbrock_func subroutine rosenbrock_grad ( me , x , g , a ) !! gradients for [[rosenbrock_func]]. implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( out ) :: g !! objective function partials w.r.t x `dimension(n)` real ( wp ), dimension (:,:), intent ( out ) :: a !! gradient matrix of constraints w.r.t. x `dimension(m,n)` g ( 1 ) = - 40 0.0_wp * ( x ( 2 ) - x ( 1 ) ** 2 ) * x ( 1 ) - 2.0_wp * ( 1.0_wp - x ( 1 )) !df/x1 g ( 2 ) = 20 0.0_wp * ( x ( 2 ) - x ( 1 ) ** 2 ) !df/x2 a ( 1 , 1 ) = - 2.0_wp * x ( 1 ) ! dc/dx1 a ( 1 , 2 ) = - 2.0_wp * x ( 2 ) ! dc/dx2 end subroutine rosenbrock_grad subroutine report_iteration ( me , iter , x , f , c ) use , intrinsic :: iso_fortran_env , only : output_unit !! report an iteration (print to the console). implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: iter real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), intent ( in ) :: f real ( wp ), dimension (:), intent ( in ) :: c !write a header: if ( iter == 0 ) then write ( output_unit , '(*(A20,1X))' ) 'iteration' , 'x(1)' , 'x(2)' , 'f(1)' , 'c(1)' end if !write the iteration data: write ( output_unit , '(I20,1X,(*(F20.16,1X)))' ) iter , x , f , c end subroutine report_iteration end program slsqp_test !*******************************************************************************","tags":"","loc":"sourcefile/slsqp_test.f90.html","title":"slsqp_test.f90 – slsqp"},{"text":"type, public :: slsqp_solver type~~slsqp_solver~~InheritsGraph type~slsqp_solver slsqp_solver type~linmin_data linmin_data type~linmin_data->type~slsqp_solver linmin type~slsqpb_data slsqpb_data type~slsqpb_data->type~slsqp_solver slsqpb Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). The main class used to interface with the SLSQP solver. Variables n m meq max_iter acc alphamin alphamax iprint xl xu l_w w l_jw jw f g report linesearch_mode linmin slsqpb user_triggered_stop Type-Bound Procedures initialize destroy optimize abort report_message Source Code slsqp_solver Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of optimization variables ( n > 0 ) integer, private :: m = 0 number of constraints ( m \\ge 0 ) integer, private :: meq = 0 number of equality constraints ( m \\ge m_{eq} \\ge 0 ) integer, private :: max_iter = 0 maximum number of iterations real(kind=wp), private :: acc = zero accuracy tolerance real(kind=wp), private :: alphamin = 0.1_wp min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real(kind=wp), private :: alphamax = 1.0_wp max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  integer, private :: iprint = output_unit unit number of status printing (0 for no printing) real(kind=wp), private, dimension(:), allocatable :: xl lower bound on x real(kind=wp), private, dimension(:), allocatable :: xu upper bound on x integer, private :: l_w = 0 size of w real(kind=wp), private, dimension(:), allocatable :: w real work array integer, private :: l_jw = 0 size of jw integer, private, dimension(:), allocatable :: jw integer work array procedure( func ), private, pointer :: f => null() problem function subroutine procedure( grad ), private, pointer :: g => null() gradient subroutine procedure( iterfunc ), private, pointer :: report => null() for reporting an iteration integer, private :: linesearch_mode = 1 linesearch mode: 1 = inexact (Armijo) linesearch, 2 = exact linesearch. type( linmin_data ), private :: linmin data formerly within linmin .\n Only used when linesearch_mode=2 type( slsqpb_data ), private :: slsqpb data formerly within slsqpb . logical, private :: user_triggered_stop = .false. if the abort method has been called\n to stop the iterations Type-Bound Procedures procedure, public :: initialize => initialize_slsqp private subroutine initialize_slsqp (me, n, m, meq, max_iter, acc, f, g, xl, xu, status_ok, linesearch_mode, iprint, report, alphamin, alphamax) initialize the slsqp_solver class.  see slsqp for more details. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: n the number of varibles,  n \\ge 1  integer, intent(in) :: m total number of constraints,  m \\ge 0  integer, intent(in) :: meq number of equality constraints,  m_{eq} \\ge 0  integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: acc accuracy procedure( func ) :: f problem function procedure( grad ) :: g function to compute gradients real(kind=wp), intent(in), dimension(n) :: xl lower bounds on x real(kind=wp), intent(in), dimension(n) :: xu upper bounds on x logical, intent(out) :: status_ok will be false if there were errors integer, intent(in), optional :: linesearch_mode 1 = inexact (default), 2 = exact integer, intent(in), optional :: iprint unit number of status messages (default=output_unit) procedure( iterfunc ), optional :: report user-defined procedure that will be called once per iteration real(kind=wp), intent(in), optional :: alphamin minimum alpha for linesearch [default 0.1] real(kind=wp), intent(in), optional :: alphamax maximum alpha for linesearch [default 1.0] procedure, public :: destroy => destroy_slsqp private subroutine destroy_slsqp (me) destructor for slsqp_solver . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(out) :: me procedure, public :: optimize => slsqp_wrapper private subroutine slsqp_wrapper (me, x, istat, iterations, status_message) main routine for calling slsqp . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x in: initial optimization variables, out: solution. integer, intent(out) :: istat status code (see mode in slsqp ). integer, intent(out), optional :: iterations number of iterations character(len=:), intent(out), optional allocatable :: status_message string status message corresponding to istat procedure, public :: abort => stop_iterations private subroutine stop_iterations (me) A method that the user can call to stop the iterations.\n  (it can be called in any of the functions).\n  SLSQP will stop at the end of the next iteration. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me procedure, private :: report_message for reporting messages to the user private subroutine report_message (me, str, ival, rval, fatal) Report a message from an slsqp_solver class. This uses the iprint variable in the class as the unit number for printing. Note: for fatal errors,\n  if no unit is specified, the error_unit is used. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(in) :: me character(len=*), intent(in) :: str the message to report. integer, intent(in), optional :: ival optional integer to print after the message. real(kind=wp), intent(in), optional :: rval optional real to print after the message. logical, intent(in), optional :: fatal if True, then the program is stopped (default=False). Source Code type , public :: slsqp_solver !! The main class used to interface with the SLSQP solver. private integer :: n = 0 !! number of optimization variables ( n > 0 ) integer :: m = 0 !! number of constraints ( m \\ge 0 ) integer :: meq = 0 !! number of equality constraints ( m \\ge m_{eq} \\ge 0 ) integer :: max_iter = 0 !! maximum number of iterations real ( wp ) :: acc = zero !! accuracy tolerance !these two were not in the original code: real ( wp ) :: alphamin = 0.1_wp !! min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ) :: alphamax = 1.0_wp !! max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  integer :: iprint = output_unit !! unit number of status printing (0 for no printing) real ( wp ), dimension (:), allocatable :: xl !! lower bound on x real ( wp ), dimension (:), allocatable :: xu !! upper bound on x integer :: l_w = 0 !! size of `w` real ( wp ), dimension (:), allocatable :: w !! real work array integer :: l_jw = 0 !! size of `jw` integer , dimension (:), allocatable :: jw !! integer work array procedure ( func ), pointer :: f => null () !! problem function subroutine procedure ( grad ), pointer :: g => null () !! gradient subroutine procedure ( iterfunc ), pointer :: report => null () !! for reporting an iteration integer :: linesearch_mode = 1 !! linesearch mode: !! !! * `1` = inexact (Armijo) linesearch, !! * `2` = exact linesearch. type ( linmin_data ) :: linmin !! data formerly within [[linmin]]. !! Only used when `linesearch_mode=2` type ( slsqpb_data ) :: slsqpb !! data formerly within [[slsqpb]]. logical :: user_triggered_stop = . false . !! if the `abort` method has been called !! to stop the iterations contains private procedure , public :: initialize => initialize_slsqp procedure , public :: destroy => destroy_slsqp procedure , public :: optimize => slsqp_wrapper procedure , public :: abort => stop_iterations procedure :: report_message !! for reporting messages to the user end type slsqp_solver","tags":"","loc":"type/slsqp_solver.html","title":"slsqp_solver – slsqp "},{"text":"type, public :: linmin_data data formerly saved in linmin routine. Inherited By type~~linmin_data~~InheritedByGraph type~linmin_data linmin_data type~slsqp_solver slsqp_solver type~linmin_data->type~slsqp_solver linmin Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables a b d e p q r u v w x m fu fv fw fx tol1 tol2 Type-Bound Procedures destroy Source Code linmin_data Components Type Visibility Attributes Name Initial real(kind=wp), public :: a = zero real(kind=wp), public :: b = zero real(kind=wp), public :: d = zero real(kind=wp), public :: e = zero real(kind=wp), public :: p = zero real(kind=wp), public :: q = zero real(kind=wp), public :: r = zero real(kind=wp), public :: u = zero real(kind=wp), public :: v = zero real(kind=wp), public :: w = zero real(kind=wp), public :: x = zero real(kind=wp), public :: m = zero real(kind=wp), public :: fu = zero real(kind=wp), public :: fv = zero real(kind=wp), public :: fw = zero real(kind=wp), public :: fx = zero real(kind=wp), public :: tol1 = zero real(kind=wp), public :: tol2 = zero Type-Bound Procedures procedure, public :: destroy => destroy_linmin_data private subroutine destroy_linmin_data (me) Destructor for linmin_data type. Arguments Type Intent Optional Attributes Name class( linmin_data ), intent(out) :: me Source Code type , public :: linmin_data !! data formerly saved in [[linmin]] routine. real ( wp ) :: a = zero real ( wp ) :: b = zero real ( wp ) :: d = zero real ( wp ) :: e = zero real ( wp ) :: p = zero real ( wp ) :: q = zero real ( wp ) :: r = zero real ( wp ) :: u = zero real ( wp ) :: v = zero real ( wp ) :: w = zero real ( wp ) :: x = zero real ( wp ) :: m = zero real ( wp ) :: fu = zero real ( wp ) :: fv = zero real ( wp ) :: fw = zero real ( wp ) :: fx = zero real ( wp ) :: tol1 = zero real ( wp ) :: tol2 = zero contains procedure :: destroy => destroy_linmin_data end type linmin_data","tags":"","loc":"type/linmin_data.html","title":"linmin_data – slsqp "},{"text":"type, public :: slsqpb_data data formerly saved in slsqpb . Inherited By type~~slsqpb_data~~InheritedByGraph type~slsqpb_data slsqpb_data type~slsqp_solver slsqp_solver type~slsqpb_data->type~slsqp_solver slsqpb Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables t f0 h1 h2 h3 h4 t0 gs tol alpha line iexact incons ireset itermx n1 n2 n3 Type-Bound Procedures destroy Source Code slsqpb_data Components Type Visibility Attributes Name Initial real(kind=wp), public :: t = zero real(kind=wp), public :: f0 = zero real(kind=wp), public :: h1 = zero real(kind=wp), public :: h2 = zero real(kind=wp), public :: h3 = zero real(kind=wp), public :: h4 = zero real(kind=wp), public :: t0 = zero real(kind=wp), public :: gs = zero real(kind=wp), public :: tol = zero real(kind=wp), public :: alpha = zero integer, public :: line = 0 integer, public :: iexact = 0 integer, public :: incons = 0 integer, public :: ireset = 0 integer, public :: itermx = 0 integer, public :: n1 = 0 integer, public :: n2 = 0 integer, public :: n3 = 0 Type-Bound Procedures procedure, public :: destroy => destroy_slsqpb_data private subroutine destroy_slsqpb_data (me) Destructor for slsqpb_data type. Arguments Type Intent Optional Attributes Name class( slsqpb_data ), intent(out) :: me Source Code type , public :: slsqpb_data !! data formerly saved in [[slsqpb]]. real ( wp ) :: t = zero real ( wp ) :: f0 = zero real ( wp ) :: h1 = zero real ( wp ) :: h2 = zero real ( wp ) :: h3 = zero real ( wp ) :: h4 = zero real ( wp ) :: t0 = zero real ( wp ) :: gs = zero real ( wp ) :: tol = zero real ( wp ) :: alpha = zero integer :: line = 0 integer :: iexact = 0 integer :: incons = 0 integer :: ireset = 0 integer :: itermx = 0 integer :: n1 = 0 integer :: n2 = 0 integer :: n3 = 0 contains procedure :: destroy => destroy_slsqpb_data end type slsqpb_data","tags":"","loc":"type/slsqpb_data.html","title":"slsqpb_data – slsqp "},{"text":"abstract interface private subroutine func(me, x, f, c) Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out) :: f value of the objective function real(kind=wp), intent(out), dimension(:) :: c the constraint vector dimension(m) ,\n equality constraints (if any) first. Description for computing the function","tags":"","loc":"interface/func.html","title":"func – slsqp"},{"text":"abstract interface private subroutine grad(me, x, g, a) Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out), dimension(:) :: g objective function partials w.r.t x dimension(n) real(kind=wp), intent(out), dimension(:,:) :: a gradient matrix of constraints w.r.t. x dimension(m,n) Description for computing the gradients","tags":"","loc":"interface/grad.html","title":"grad – slsqp"},{"text":"abstract interface private subroutine iterfunc(me, iter, x, f, c) Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: iter iteration number real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(in) :: f value of the objective function real(kind=wp), intent(in), dimension(:) :: c the constraint vector dimension(m) ,\n equality constraints (if any) first. Description for reporting an iteration","tags":"","loc":"interface/iterfunc.html","title":"iterfunc – slsqp"},{"text":"public function ddot(n, dx, incx, dy, incy) forms the dot product of two vectors.\n  uses unrolled loops for increments equal to one. Author jack dongarra, linpack, 3/11/78. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy Return Value real(kind=wp) Called By proc~~ddot~~CalledByGraph proc~ddot ddot proc~lsi lsi proc~lsi->proc~ddot proc~ldp ldp proc~lsi->proc~ldp proc~slsqpb slsqpb proc~slsqpb->proc~ddot proc~lsq lsq proc~slsqpb->proc~lsq proc~ldp->proc~ddot proc~lsq->proc~ddot proc~lsei lsei proc~lsq->proc~lsei proc~lsei->proc~ddot proc~lsei->proc~lsi proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp var panprocddotCalledByGraph = svgPanZoom('#procddotCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ddot Source Code real ( wp ) function ddot ( n , dx , incx , dy , incy ) implicit none real ( wp ) :: dx ( * ) , dy ( * ) , dtemp integer :: i , incx , incy , ix , iy , m , mp1 , n ddot = zero dtemp = zero if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dtemp = dtemp + dx ( i ) * dy ( i ) end do if ( n < 5 ) then ddot = dtemp return end if end if mp1 = m + 1 do i = mp1 , n , 5 dtemp = dtemp + dx ( i ) * dy ( i ) + dx ( i + 1 ) * dy ( i + 1 ) + & dx ( i + 2 ) * dy ( i + 2 ) + dx ( i + 3 ) * dy ( i + 3 ) + dx ( i + 4 ) * dy ( i + 4 ) end do ddot = dtemp else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dtemp = dtemp + dx ( ix ) * dy ( iy ) ix = ix + incx iy = iy + incy end do ddot = dtemp end if end function ddot","tags":"","loc":"proc/ddot.html","title":"ddot – slsqp"},{"text":"public function dnrm2(n, x, incx) Function that returns the Euclidean norm\n   \\sqrt{ \\mathbf{x}&#94;T \\mathbf{x} }  of a vector  \\mathbf{x} . Further details this version written on 25-october-1982. modified on 14-october-1993 to inline the call to dlassq.\n    sven hammarling, nag ltd. Converted to modern Fortran, Jacob Williams, Jan. 2016. Note Replaced original SLSQP routine with this one from BLAS . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(*) :: x integer, intent(in) :: incx Return Value real(kind=wp) Called By proc~~dnrm2~~CalledByGraph proc~dnrm2 dnrm2 proc~slsqpb slsqpb proc~slsqpb->proc~dnrm2 proc~lsq lsq proc~slsqpb->proc~lsq proc~lsei lsei proc~lsei->proc~dnrm2 proc~lsi lsi proc~lsei->proc~lsi proc~ldp ldp proc~ldp->proc~dnrm2 proc~lsi->proc~dnrm2 proc~lsi->proc~ldp proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp proc~lsq->proc~lsei var panprocdnrm2CalledByGraph = svgPanZoom('#procdnrm2CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code dnrm2 Source Code real ( wp ) function dnrm2 ( n , x , incx ) implicit none integer , intent ( in ) :: incx integer , intent ( in ) :: n real ( wp ), dimension ( * ), intent ( in ) :: x real ( wp ) :: absxi , norm , scale , ssq integer :: ix if ( n < 1 . or . incx < 1 ) then norm = zero elseif ( n == 1 ) then norm = abs ( x ( 1 )) else scale = zero ssq = one ! the following loop is equivalent to this call to the lapack ! auxiliary routine: ! call dlassq( n, x, incx, scale, ssq ) do ix = 1 , 1 + ( n - 1 ) * incx , incx if ( x ( ix ) /= zero ) then absxi = abs ( x ( ix )) if ( scale < absxi ) then ssq = one + ssq * ( scale / absxi ) ** 2 scale = absxi else ssq = ssq + ( absxi / scale ) ** 2 end if end if end do norm = scale * sqrt ( ssq ) end if dnrm2 = norm end function dnrm2","tags":"","loc":"proc/dnrm2.html","title":"dnrm2 – slsqp"},{"text":"public subroutine daxpy(n, da, dx, incx, dy, incy) constant times a vector plus a vector.\n  uses unrolled loops for increments equal to one. Author jack dongarra, linpack, 3/11/78. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: da real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy Called By proc~~daxpy~~CalledByGraph proc~daxpy daxpy proc~slsqpb slsqpb proc~slsqpb->proc~daxpy proc~lsq lsq proc~slsqpb->proc~lsq proc~ldp ldp proc~ldp->proc~daxpy proc~lsi lsi proc~lsi->proc~daxpy proc~lsi->proc~ldp proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp proc~lsei lsei proc~lsei->proc~lsi proc~lsq->proc~lsei var panprocdaxpyCalledByGraph = svgPanZoom('#procdaxpyCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code daxpy Source Code subroutine daxpy ( n , da , dx , incx , dy , incy ) implicit none real ( wp ) :: dx ( * ) , dy ( * ) , da integer :: i , incx , incy , ix , iy , m , mp1 , n if ( n <= 0 ) return if ( da == zero ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 4 ) if ( m /= 0 ) then do i = 1 , m dy ( i ) = dy ( i ) + da * dx ( i ) end do if ( n < 4 ) return end if mp1 = m + 1 do i = mp1 , n , 4 dy ( i ) = dy ( i ) + da * dx ( i ) dy ( i + 1 ) = dy ( i + 1 ) + da * dx ( i + 1 ) dy ( i + 2 ) = dy ( i + 2 ) + da * dx ( i + 2 ) dy ( i + 3 ) = dy ( i + 3 ) + da * dx ( i + 3 ) end do else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dy ( iy ) + da * dx ( ix ) ix = ix + incx iy = iy + incy end do end if end subroutine daxpy","tags":"","loc":"proc/daxpy.html","title":"daxpy – slsqp"},{"text":"public subroutine dcopy(n, dx, incx, dy, incy) copies a vector, x, to a vector, y.\n  uses unrolled loops for increments equal to one. Author jack dongarra, linpack, 3/11/78. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy Called By proc~~dcopy~~CalledByGraph proc~dcopy dcopy proc~slsqpb slsqpb proc~slsqpb->proc~dcopy proc~lsq lsq proc~slsqpb->proc~lsq proc~ldp ldp proc~ldp->proc~dcopy proc~lsq->proc~dcopy proc~lsei lsei proc~lsq->proc~lsei proc~lsei->proc~dcopy proc~lsi lsi proc~lsei->proc~lsi proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp proc~lsi->proc~ldp var panprocdcopyCalledByGraph = svgPanZoom('#procdcopyCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code dcopy Source Code subroutine dcopy ( n , dx , incx , dy , incy ) implicit none real ( wp ) :: dx ( * ) , dy ( * ) integer :: i , incx , incy , ix , iy , m , mp1 , n if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 7 ) if ( m /= 0 ) then do i = 1 , m dy ( i ) = dx ( i ) end do if ( n < 7 ) return end if mp1 = m + 1 do i = mp1 , n , 7 dy ( i ) = dx ( i ) dy ( i + 1 ) = dx ( i + 1 ) dy ( i + 2 ) = dx ( i + 2 ) dy ( i + 3 ) = dx ( i + 3 ) dy ( i + 4 ) = dx ( i + 4 ) dy ( i + 5 ) = dx ( i + 5 ) dy ( i + 6 ) = dx ( i + 6 ) end do else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dx ( ix ) ix = ix + incx iy = iy + incy end do end if end subroutine dcopy","tags":"","loc":"proc/dcopy.html","title":"dcopy – slsqp"},{"text":"public subroutine dscal(n, da, dx, incx) scales a vector by a constant.\n  uses unrolled loops for increment equal to one. Author jack dongarra, linpack, 3/11/78. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: da real(kind=wp) :: dx (*) integer :: incx Called By proc~~dscal~~CalledByGraph proc~dscal dscal proc~slsqpb slsqpb proc~slsqpb->proc~dscal proc~lsq lsq proc~slsqpb->proc~lsq proc~lsq->proc~dscal proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code dscal Source Code subroutine dscal ( n , da , dx , incx ) implicit none real ( wp ) :: da , dx ( * ) integer :: i , incx , m , mp1 , n , nincx if ( n <= 0 . or . incx <= 0 ) return if ( incx == 1 ) then ! code for increment equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dx ( i ) = da * dx ( i ) end do if ( n < 5 ) return end if mp1 = m + 1 do i = mp1 , n , 5 dx ( i ) = da * dx ( i ) dx ( i + 1 ) = da * dx ( i + 1 ) dx ( i + 2 ) = da * dx ( i + 2 ) dx ( i + 3 ) = da * dx ( i + 3 ) dx ( i + 4 ) = da * dx ( i + 4 ) end do else ! code for increment not equal to 1 nincx = n * incx do i = 1 , nincx , incx dx ( i ) = da * dx ( i ) end do end if end subroutine dscal","tags":"","loc":"proc/dscal.html","title":"dscal – slsqp"},{"text":"private pure function mode_to_status_message(imode) result(message) Convert the slsqp mode flag to a message string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: imode Return Value character(len=:),\n  allocatable Called By proc~~mode_to_status_message~~CalledByGraph proc~mode_to_status_message mode_to_status_message proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~mode_to_status_message Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code mode_to_status_message Source Code pure function mode_to_status_message ( imode ) result ( message ) implicit none integer , intent ( in ) :: imode character ( len = :), allocatable :: message select case ( imode ) case ( 0 ) !required accuracy for solution obtained message = 'Required accuracy for solution obtained' case ( - 100 ) message = 'Invalid size(x) in slsqp_wrapper' case ( - 101 ) message = 'Invalid linesearch_mode in slsqp_wrapper' case ( - 102 ) message = 'Function is not associated' case ( - 103 ) message = 'Gradient function is not associated' case ( - 2 ) message = 'User-triggered stop of slsqp' case ( 1 , - 1 ) message = 'In progress' case ( 2 ) message = 'Number of equality constraints larger than n' case ( 3 ) message = 'More than 3*n iterations in lsq subproblem' case ( 4 ) message = 'Inequality constraints incompatible' case ( 5 ) message = 'Singular matrix e in lsq subproblem' case ( 6 ) message = 'Singular matrix c in lsq subproblem' case ( 7 ) message = 'Rank-deficient equality constraint subproblem hfti' case ( 8 ) message = 'Positive directional derivative for linesearch' case ( 9 ) message = 'More than max_iter iterations in slsqp' case default message = 'Unknown slsqp error' end select end function mode_to_status_message","tags":"","loc":"proc/mode_to_status_message.html","title":"mode_to_status_message – slsqp"},{"text":"private subroutine stop_iterations(me) A method that the user can call to stop the iterations.\n  (it can be called in any of the functions).\n  SLSQP will stop at the end of the next iteration. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me Source Code stop_iterations Source Code subroutine stop_iterations ( me ) implicit none class ( slsqp_solver ), intent ( inout ) :: me me % user_triggered_stop = . true . end subroutine stop_iterations","tags":"","loc":"proc/stop_iterations.html","title":"stop_iterations – slsqp"},{"text":"private subroutine initialize_slsqp(me, n, m, meq, max_iter, acc, f, g, xl, xu, status_ok, linesearch_mode, iprint, report, alphamin, alphamax) initialize the slsqp_solver class.  see slsqp for more details. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: n the number of varibles,  n \\ge 1  integer, intent(in) :: m total number of constraints,  m \\ge 0  integer, intent(in) :: meq number of equality constraints,  m_{eq} \\ge 0  integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: acc accuracy procedure( func ) :: f problem function procedure( grad ) :: g function to compute gradients real(kind=wp), intent(in), dimension(n) :: xl lower bounds on x real(kind=wp), intent(in), dimension(n) :: xu upper bounds on x logical, intent(out) :: status_ok will be false if there were errors integer, intent(in), optional :: linesearch_mode 1 = inexact (default), 2 = exact integer, intent(in), optional :: iprint unit number of status messages (default=output_unit) procedure( iterfunc ), optional :: report user-defined procedure that will be called once per iteration real(kind=wp), intent(in), optional :: alphamin minimum alpha for linesearch [default 0.1] real(kind=wp), intent(in), optional :: alphamax maximum alpha for linesearch [default 1.0] Source Code initialize_slsqp Source Code subroutine initialize_slsqp ( me , n , m , meq , max_iter , acc , f , g , xl , xu , status_ok ,& linesearch_mode , iprint , report , alphamin , alphamax ) implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: n !! the number of varibles,  n \\ge 1  integer , intent ( in ) :: m !! total number of constraints,  m \\ge 0  integer , intent ( in ) :: meq !! number of equality constraints,  m_{eq} \\ge 0  integer , intent ( in ) :: max_iter !! maximum number of iterations procedure ( func ) :: f !! problem function procedure ( grad ) :: g !! function to compute gradients real ( wp ), dimension ( n ), intent ( in ) :: xl !! lower bounds on `x` real ( wp ), dimension ( n ), intent ( in ) :: xu !! upper bounds on `x` real ( wp ), intent ( in ) :: acc !! accuracy logical , intent ( out ) :: status_ok !! will be false if there were errors integer , intent ( in ), optional :: linesearch_mode !! 1 = inexact (default), 2 = exact integer , intent ( in ), optional :: iprint !! unit number of status messages (default=output_unit) procedure ( iterfunc ), optional :: report !! user-defined procedure that will be called once per iteration real ( wp ), intent ( in ), optional :: alphamin !! minimum alpha for linesearch [default 0.1] real ( wp ), intent ( in ), optional :: alphamax !! maximum alpha for linesearch [default 1.0] integer :: n1 , mineq , i status_ok = . false . call me % destroy () if ( present ( iprint )) me % iprint = iprint if ( size ( xl ) /= size ( xu ) . or . size ( xl ) /= n ) then call me % report_message ( 'error: invalid upper or lower bound vector size' ) call me % report_message ( '  size(xl) =' , ival = size ( xl )) call me % report_message ( '  size(xu) =' , ival = size ( xu )) call me % report_message ( '  n        =' , ival = n ) else if ( meq < 0 . or . meq > m ) then call me % report_message ( 'error: invalid meq value:' , ival = meq ) else if ( m < 0 ) then call me % report_message ( 'error: invalid m value:' , ival = m ) else if ( n < 1 ) then call me % report_message ( 'error: invalid n value:' , ival = n ) else if ( any ( xl > xu )) then call me % report_message ( 'error: lower bounds must be <= upper bounds.' ) do i = 1 , n if ( xl ( i ) > xu ( i )) then call me % report_message ( '  xl(i)>xu(i) for variable' , ival = i ) end if end do else if ( present ( linesearch_mode )) then !two linesearch modes: select case ( linesearch_mode ) case ( 1 ) !inexact me % linesearch_mode = linesearch_mode case ( 2 ) !exact me % linesearch_mode = linesearch_mode case default call me % report_message ( 'error: invalid linesearch_mode (must be 1 or 2): ' ,& ival = linesearch_mode ) call me % destroy () return end select end if !optional linesearch bounds: if ( present ( alphamin )) me % alphamin = alphamin if ( present ( alphamax )) me % alphamax = alphamax !verify valid values for alphamin and alphamax: 0<alphamin<alphamax<=1 if ( me % alphamin <= zero . or . me % alphamax <= zero . or . & me % alphamax <= me % alphamin . or . & me % alphamin >= one . or . me % alphamax > one ) then call me % report_message ( 'error: invalid values for alphamin or alphamax.' ) call me % report_message ( '  alphamin =' , rval = me % alphamin ) call me % report_message ( '  alphamax =' , rval = me % alphamax ) call me % destroy () return end if status_ok = . true . me % n = n me % m = m me % meq = meq me % max_iter = max_iter me % acc = acc me % f => f me % g => g if ( present ( report )) me % report => report allocate ( me % xl ( n )); me % xl = xl allocate ( me % xu ( n )); me % xu = xu !work arrays: n1 = n + 1 mineq = m - meq + 2 * n1 me % l_w = n1 * ( n1 + 1 ) + meq * ( n1 + 1 ) + mineq * ( n1 + 1 ) + & !for lsq ( n1 - meq + 1 ) * ( mineq + 2 ) + 2 * mineq + & !for lsi ( n1 + mineq ) * ( n1 - meq ) + 2 * meq + n1 + & !for lsei n1 * n / 2 + 2 * m + 3 * n + 3 * n1 + 1 !for slsqpb allocate ( me % w ( me % l_w )) me % w = zero me % l_jw = mineq allocate ( me % jw ( me % l_jw )) me % jw = 0 end if end subroutine initialize_slsqp","tags":"","loc":"proc/initialize_slsqp.html","title":"initialize_slsqp – slsqp"},{"text":"private subroutine destroy_slsqp(me) destructor for slsqp_solver . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(out) :: me Source Code destroy_slsqp Source Code subroutine destroy_slsqp ( me ) implicit none class ( slsqp_solver ), intent ( out ) :: me end subroutine destroy_slsqp","tags":"","loc":"proc/destroy_slsqp.html","title":"destroy_slsqp – slsqp"},{"text":"private subroutine slsqp_wrapper(me, x, istat, iterations, status_message) main routine for calling slsqp . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x in: initial optimization variables, out: solution. integer, intent(out) :: istat status code (see mode in slsqp ). integer, intent(out), optional :: iterations number of iterations character(len=:), intent(out), optional allocatable :: status_message string status message corresponding to istat Calls proc~~slsqp_wrapper~~CallsGraph proc~slsqp_wrapper slsqp_wrapper proc~slsqp slsqp proc~slsqp_wrapper->proc~slsqp proc~mode_to_status_message mode_to_status_message proc~slsqp_wrapper->proc~mode_to_status_message proc~slsqpb slsqpb proc~slsqp->proc~slsqpb proc~enforce_bounds enforce_bounds proc~slsqpb->proc~enforce_bounds proc~daxpy daxpy proc~slsqpb->proc~daxpy proc~ldl ldl proc~slsqpb->proc~ldl proc~linmin linmin proc~slsqpb->proc~linmin proc~ddot ddot proc~slsqpb->proc~ddot proc~lsq lsq proc~slsqpb->proc~lsq proc~dscal dscal proc~slsqpb->proc~dscal proc~dnrm2 dnrm2 proc~slsqpb->proc~dnrm2 proc~dcopy dcopy proc~slsqpb->proc~dcopy proc~lsq->proc~enforce_bounds proc~lsq->proc~ddot proc~lsq->proc~dscal proc~lsq->proc~dcopy proc~lsei lsei proc~lsq->proc~lsei proc~lsei->proc~ddot proc~lsei->proc~dnrm2 proc~lsei->proc~dcopy proc~lsi lsi proc~lsei->proc~lsi proc~hfti hfti proc~lsei->proc~hfti proc~h12 h12 proc~lsei->proc~h12 proc~lsi->proc~daxpy proc~lsi->proc~ddot proc~lsi->proc~dnrm2 proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~hfti->proc~h12 proc~diff diff proc~hfti->proc~diff proc~ldp->proc~daxpy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~ldp->proc~dcopy proc~ldp->proc~diff proc~nnls nnls proc~ldp->proc~nnls proc~nnls->proc~h12 proc~nnls->proc~diff proc~g1 g1 proc~nnls->proc~g1 var panprocslsqp_wrapperCallsGraph = svgPanZoom('#procslsqp_wrapperCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code slsqp_wrapper Source Code subroutine slsqp_wrapper ( me , x , istat , iterations , status_message ) implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x !! **in:**  initial optimization variables, !! **out:** solution. integer , intent ( out ) :: istat !! status code (see `mode` in [[slsqp]]). integer , intent ( out ), optional :: iterations !! number of iterations character ( len = :), intent ( out ), allocatable , optional :: status_message !! string status message corresponding to `istat` !local variables: real ( wp ) :: f !! objective function real ( wp ), dimension ( max ( 1 , me % m )) :: c !! constraint vector real ( wp ), dimension ( max ( 1 , me % m ), me % n + 1 ) :: a !! a matrix for slsqp real ( wp ), dimension ( me % n + 1 ) :: g !! g matrix for slsqp real ( wp ), dimension ( me % m ) :: cvec !! constraint vector real ( wp ), dimension ( me % n ) :: dfdx !! objective function partials real ( wp ), dimension ( me % m , me % n ) :: dcdx !! constraint partials integer :: i !! iteration counter integer :: mode !! reverse communication flag for [[slsqp]] integer :: la !! input to [[slsqp]] integer :: iter !! in/out for [[slsqp]] real ( wp ) :: acc !! in/out for [[slsqp]] !initialize: i = 0 iter = me % max_iter la = max ( 1 , me % m ) mode = 0 a = zero g = zero c = zero if ( present ( iterations )) iterations = 0 call me % linmin % destroy () call me % slsqpb % destroy () !check setup: if ( size ( x ) /= me % n ) then istat = - 100 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if !linesearch: select case ( me % linesearch_mode ) case ( 1 ) !inexact (armijo-type linesearch) acc = abs ( me % acc ) case ( 2 ) !exact acc = - abs ( me % acc ) case default istat = - 101 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end select !make sure the functions have been associated: if (. not . associated ( me % f )) then istat = - 102 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if (. not . associated ( me % g )) then istat = - 103 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if !main solver loop: do if ( mode == 0 . or . mode == 1 ) then !function evaluation (f&c) call me % f ( x , f , cvec ) c ( 1 : me % m ) = cvec end if if ( mode == 0 . or . mode ==- 1 ) then !gradient evaluation (g&a) call me % g ( x , dfdx , dcdx ) g ( 1 : me % n ) = dfdx a ( 1 : me % m , 1 : me % n ) = dcdx !this is an iteration: !note: the initial guess is reported as iteration 0: if ( associated ( me % report )) call me % report ( i , x , f , c ) !report iteration i = i + 1 ! iteration counter end if !main routine: call slsqp ( me % m , me % meq , la , me % n , x , me % xl , me % xu ,& f , c , g , a , acc , iter , mode ,& me % w , me % l_w , me % jw , me % l_jw ,& me % slsqpb , me % linmin , me % alphamin , me % alphamax ) if ( mode == 1 . or . mode ==- 1 ) then !continue to next call else if ( mode == 0 . and . associated ( me % report )) & call me % report ( i , x , f , c ) !report solution call me % report_message ( mode_to_status_message ( mode )) exit end if if ( me % user_triggered_stop ) then mode = - 2 call me % report_message ( mode_to_status_message ( mode )) me % user_triggered_stop = . false . !have to reset in case !method is called again. exit end if end do istat = mode if ( present ( iterations )) iterations = iter if ( present ( status_message )) status_message = mode_to_status_message ( istat ) end subroutine slsqp_wrapper","tags":"","loc":"proc/slsqp_wrapper.html","title":"slsqp_wrapper – slsqp"},{"text":"private subroutine report_message(me, str, ival, rval, fatal) Report a message from an slsqp_solver class. This uses the iprint variable in the class as the unit number for printing. Note: for fatal errors,\n  if no unit is specified, the error_unit is used. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(in) :: me character(len=*), intent(in) :: str the message to report. integer, intent(in), optional :: ival optional integer to print after the message. real(kind=wp), intent(in), optional :: rval optional real to print after the message. logical, intent(in), optional :: fatal if True, then the program is stopped (default=False). Source Code report_message Source Code subroutine report_message ( me , str , ival , rval , fatal ) implicit none class ( slsqp_solver ), intent ( in ) :: me character ( len =* ), intent ( in ) :: str !! the message to report. integer , intent ( in ), optional :: ival !! optional integer to print after the message. real ( wp ), intent ( in ), optional :: rval !! optional real to print after the message. logical , intent ( in ), optional :: fatal !! if True, then the program is stopped (default=False). logical :: stop_program !! true if the program is to be stopped logical :: write_message !! true if the message is to be printed character ( len = 10 ) :: istr !! string version of `ival` character ( len = 30 ) :: rstr !! string version of `rval` character ( len = :), allocatable :: str_to_write !! the actual message to the printed integer :: istat !! iostat for integer to string conversion !fatal error check: if ( present ( fatal )) then stop_program = fatal else stop_program = . false . end if !note: if stopping program, then the message is always printed: write_message = me % iprint /= 0 . or . stop_program if ( write_message ) then if ( present ( ival )) then write ( istr , fmt = '(I10)' , iostat = istat ) ival if ( istat /= 0 ) istr = '*****' str_to_write = str // ' ' // trim ( adjustl ( istr )) elseif ( present ( rval )) then write ( istr , fmt = '(F30.16)' , iostat = istat ) rval if ( istat /= 0 ) rstr = '*****' str_to_write = str // ' ' // trim ( adjustl ( rstr )) else str_to_write = str end if if ( me % iprint == 0 ) then write ( error_unit , '(A)' ) str_to_write !in this case, use the error unit else write ( me % iprint , '(A)' ) str_to_write !user specified unit number end if deallocate ( str_to_write ) if ( stop_program ) error stop 'Fatal Error' end if end subroutine report_message","tags":"","loc":"proc/report_message.html","title":"report_message – slsqp"},{"text":"private pure elemental function diff(u, v) result(d) Replaced statement function in the original code.\n  Returns  d = u - v . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: u real(kind=wp), intent(in) :: v Return Value real(kind=wp) Called By proc~~diff~~CalledByGraph proc~diff diff proc~hfti hfti proc~hfti->proc~diff proc~nnls nnls proc~nnls->proc~diff proc~ldp ldp proc~ldp->proc~diff proc~ldp->proc~nnls proc~lsei lsei proc~lsei->proc~hfti proc~lsi lsi proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp proc~lsi->proc~ldp var panprocdiffCalledByGraph = svgPanZoom('#procdiffCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code diff Source Code pure elemental function diff ( u , v ) result ( d ) implicit none real ( wp ), intent ( in ) :: u real ( wp ), intent ( in ) :: v real ( wp ) :: d d = u - v end function diff","tags":"","loc":"proc/diff.html","title":"diff – slsqp"},{"text":"private function linmin(mode, ax, bx, f, tol, a, b, d, e, p, q, r, u, v, w, x, m, fu, fv, fw, fx, tol1, tol2) Linesearch without derivatives (used by slsqp if linesearch_mode=2 ).\n  Returns the abscissa approximating the point where f attains a minimum. purpose: to find the argument linmin where the function f takes it's minimum\n  on the interval ax , bx . It uses a combination of golden section\n  and successive quadratic interpolation. Reference This function subprogram is a slightly modified version of the\n  ALGOL 60 procedure localmin given in R.P. Brent:\n  \" Algorithms for minimization without derivatives \",\n  Prentice-Hall (1973). History Kraft, D., DFVLR - institut fuer dynamik der flugsysteme\n    d-8031  oberpfaffenhofen status: 31. august 1984 Jacob Williams, Jan 2016, Refactored into modern Fortran.\n    Added saved variables as inout s to make the routine thread-safe. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: mode controls reverse communication\n must be set to 0 initially, returns with intermediate\n values 1 and 2 which must not be changed by the user,\n ends with convergence with value 3. real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp) :: f function value at linmin which is to be brought in by\n reverse communication controlled by mode real(kind=wp), intent(in) :: tol desired length of interval of uncertainty of final result real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(inout) :: d real(kind=wp), intent(inout) :: e real(kind=wp), intent(inout) :: p real(kind=wp), intent(inout) :: q real(kind=wp), intent(inout) :: r real(kind=wp), intent(inout) :: u real(kind=wp), intent(inout) :: v real(kind=wp), intent(inout) :: w real(kind=wp), intent(inout) :: x real(kind=wp), intent(inout) :: m real(kind=wp), intent(inout) :: fu real(kind=wp), intent(inout) :: fv real(kind=wp), intent(inout) :: fw real(kind=wp), intent(inout) :: fx real(kind=wp), intent(inout) :: tol1 real(kind=wp), intent(inout) :: tol2 Return Value real(kind=wp) Called By proc~~linmin~~CalledByGraph proc~linmin linmin proc~slsqpb slsqpb proc~slsqpb->proc~linmin proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code linmin Source Code real ( wp ) function linmin ( mode , ax , bx , f , tol ,& a , b , d , e , p , q , r , u , v ,& w , x , m , fu , fv , fw , fx , tol1 , tol2 ) implicit none integer , intent ( inout ) :: mode !! controls reverse communication !! must be set to 0 initially, returns with intermediate !! values 1 and 2 which must not be changed by the user, !! ends with convergence with value 3. real ( wp ) :: f !! function value at `linmin` which is to be brought in by !! reverse communication controlled by `mode` real ( wp ), intent ( in ) :: tol !! desired length of interval of uncertainty of final result real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( inout ) :: a , b , d , e , p , q , r , u , v , w , x , m , fu , fv , fw , fx , tol1 , tol2 real ( wp ), parameter :: c = ( 3.0_wp - sqrt ( 5.0_wp )) / 2.0_wp !! golden section ratio = `0.381966011` real ( wp ), parameter :: eps = sqrt ( epsilon ( 1.0_wp )) !! square - root of machine precision select case ( mode ) case ( 1 ) ! main loop starts here fx = f fv = fx fw = fv case ( 2 ) fu = f ! update a, b, v, w, and x if ( fu > fx ) then if ( u < x ) a = u if ( u >= x ) b = u if ( fu <= fw . or . w == x ) then v = w fv = fw w = u fw = fu else if ( fu <= fv . or . v == x . or . v == w ) then v = u fv = fu end if else if ( u >= x ) a = x if ( u < x ) b = x v = w fv = fw w = x fw = fx x = u fx = fu end if case default ! initialization a = ax b = bx e = zero v = a + c * ( b - a ) w = v x = w linmin = x mode = 1 return end select m = 0.5_wp * ( a + b ) tol1 = eps * abs ( x ) + tol tol2 = tol1 + tol1 ! test convergence if ( abs ( x - m ) <= tol2 - 0.5_wp * ( b - a ) ) then ! end of main loop linmin = x mode = 3 else r = zero q = r p = q if ( abs ( e ) > tol1 ) then ! fit parabola r = ( x - w ) * ( fx - fv ) q = ( x - v ) * ( fx - fw ) p = ( x - v ) * q - ( x - w ) * r q = q - r q = q + q if ( q > zero ) p = - p if ( q < zero ) q = - q r = e e = d end if ! is parabola acceptable if ( abs ( p ) >= 0.5_wp * abs ( q * r ) . or . p <= q * ( a - x ) . or . p >= q * ( b - x ) ) then ! golden section step if ( x >= m ) e = a - x if ( x < m ) e = b - x d = c * e else ! parabolic interpolation step d = p / q ! f must not be evaluated too close to a or b if ( u - a < tol2 ) d = sign ( tol1 , m - x ) if ( b - u < tol2 ) d = sign ( tol1 , m - x ) end if ! f must not be evaluated too close to x if ( abs ( d ) < tol1 ) d = sign ( tol1 , d ) u = x + d linmin = u mode = 2 end if end function linmin","tags":"","loc":"proc/linmin.html","title":"linmin – slsqp"},{"text":"public subroutine slsqp(m, meq, la, n, x, xl, xu, f, c, g, a, acc, iter, mode, w, l_w, jw, l_jw, sdat, ldat, alphamin, alphamax) slsqp : s equential l east sq uares p rogramming\n  to solve general nonlinear optimization problems a nonlinear programming method with quadratic programming subproblems\n  this subroutine solves the general nonlinear programming problem: minimize  f(x)  subject to  c_j (x) = 0 ,            j = 1,...,meq     c_j (x) \\ge 0 ,          j = meq+1,...,m   xl_i \\le x_i \\le xu_i ,  i = 1,...,n      the algorithm implements the method of Han and Powell\n  with BFGS-update of the b-matrix and L1-test function\n  within the steplength algorithm. Reference Dieter Kraft: \"A software package for sequential quadratic programming\",\n     DFVLR-FB 88-28, 1988 History implemented by: Dieter Kraft, DFVLR oberpfaffenhofen date: april - october, 1981. December, 31-st, 1984. March   , 21-st, 1987, revised to fortran 77 March   , 20-th, 1989, revised to ms-fortran April   , 14-th, 1989, hesse   in-line coded February, 28-th, 1991, fortran/2 version 1.04 accepts statement functions March   ,  1-st, 1991, tested with salford ftn77/386 compiler vers 2.40 in protected mode January ,        2016, Refactored into modern Fortran by Jacob Williams License Original version copyright 1991: Dieter Kraft, FHM.\n  Released under a BSD license. Note f , c , g , a must all be set by the user before each call. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m is the total number of constraints,  m \\ge 0  integer, intent(in) :: meq is the number of equality constraints,  m_{eq} \\ge 0  integer, intent(in) :: la see a ,  la \\ge \\max(m,1)  integer, intent(in) :: n is the number of variables,  n \\ge 1  real(kind=wp), intent(inout), dimension(n) :: x x() stores the current iterate of the n vector x on entry x() must be initialized. on exit x() stores the solution vector x if mode = 0 . real(kind=wp), intent(in), dimension(n) :: xl xl() stores an n vector of lower bounds xl to x . real(kind=wp), intent(in), dimension(n) :: xu xu() stores an n vector of upper bounds xu to x . real(kind=wp), intent(in) :: f is the value of the objective function. real(kind=wp), intent(in), dimension(la) :: c c() stores the m vector c of constraints,\n equality constraints (if any) first.\n dimension of c must be greater or equal la ,\n which must be greater or equal max(1,m) . real(kind=wp), intent(in), dimension(n+1) :: g g() stores the n vector g of partials of the\n objective function; dimension of g must be\n greater or equal n+1 . real(kind=wp), intent(in), dimension(la,n+1) :: a the la by n + 1 array a() stores\n the m by n matrix a of constraint normals. a() has first dimensioning parameter la ,\n which must be greater or equal max(1,m) . real(kind=wp), intent(inout) :: acc abs(acc) controls the final accuracy.\n if acc < zero an exact linesearch is performed,\n otherwise an armijo-type linesearch is used. integer, intent(inout) :: iter prescribes the maximum number of iterations.\n on exit iter indicates the number of iterations. integer, intent(inout) :: mode mode controls calculation: reverse communication is used in the sense that\n the program is initialized by mode = 0 ; then it is\n to be called repeatedly by the user until a return\n with mode /= abs(1) takes place.\n if mode = -1 gradients have to be calculated,\n while with mode = 1 functions have to be calculated.\n mode must not be changed between subsequent calls of slsqp . evaluation modes : -1 : gradient evaluation, ( g & a ) 0 : on entry : initialization, ( f , g , c , a ), on exit : required accuracy for solution obtained 1 : function evaluation, ( f & c ) failure modes : 2 : number of equality constraints larger than n 3 : more than 3*n iterations in lsq subproblem 4 : inequality constraints incompatible 5 : singular matrix e in lsq subproblem 6 : singular matrix c in lsq subproblem 7 : rank-deficient equality constraint subproblem hfti 8 : positive directional derivative for linesearch 9 : more than iter iterations in sqp >=10 : working space w or jw too small, w should be enlarged to l_w=mode/1000 , jw should be enlarged to l_jw=mode-1000*l_w real(kind=wp), intent(inout), dimension(l_w) :: w w() is a one dimensional working space.\n the first m+n+n*n1/2 elements of w must not be\n changed between subsequent calls of slsqp .\n on return w(1) ... w(m) contain the multipliers\n associated with the general constraints, while w(m+1) ... w(m+n(n+1)/2) store the cholesky factor l*d*l(t) of the approximate hessian of the\n lagrangian columnwise dense as lower triangular\n unit matrix l with d in its 'diagonal' and w(m+n(n+1)/2+n+2 ... w(m+n(n+1)/2+n+2+m+2n) contain the multipliers associated with all\n constraints of the quadratic program finding\n the search direction to the solution x* integer, intent(in) :: l_w the length of w , which should be at least: (3*n1+m)*(n1+1) for lsq +(n1-meq+1)*(mineq+2) + 2*mineq for lsi +(n1+mineq)*(n1-meq) + 2*meq + n1 for lsei + n1*n/2 + 2*m + 3*n + 3*n1 + 1 for slsqpb with mineq = m - meq + 2*n1 & n1 = n+1 integer, intent(inout), dimension(l_jw) :: jw jw() is a one dimensional integer working space integer, intent(in) :: l_jw the length of jw which should be at least mineq = m - meq + 2*(n+1) . type( slsqpb_data ), intent(inout) :: sdat data for slsqpb . type( linmin_data ), intent(inout) :: ldat data for linmin . real(kind=wp), intent(in) :: alphamin min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real(kind=wp), intent(in) :: alphamax max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  Calls proc~~slsqp~~CallsGraph proc~slsqp slsqp proc~slsqpb slsqpb proc~slsqp->proc~slsqpb proc~enforce_bounds enforce_bounds proc~slsqpb->proc~enforce_bounds proc~daxpy daxpy proc~slsqpb->proc~daxpy proc~ldl ldl proc~slsqpb->proc~ldl proc~linmin linmin proc~slsqpb->proc~linmin proc~ddot ddot proc~slsqpb->proc~ddot proc~lsq lsq proc~slsqpb->proc~lsq proc~dscal dscal proc~slsqpb->proc~dscal proc~dnrm2 dnrm2 proc~slsqpb->proc~dnrm2 proc~dcopy dcopy proc~slsqpb->proc~dcopy proc~lsq->proc~enforce_bounds proc~lsq->proc~ddot proc~lsq->proc~dscal proc~lsq->proc~dcopy proc~lsei lsei proc~lsq->proc~lsei proc~lsei->proc~ddot proc~lsei->proc~dnrm2 proc~lsei->proc~dcopy proc~lsi lsi proc~lsei->proc~lsi proc~hfti hfti proc~lsei->proc~hfti proc~h12 h12 proc~lsei->proc~h12 proc~lsi->proc~daxpy proc~lsi->proc~ddot proc~lsi->proc~dnrm2 proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~hfti->proc~h12 proc~diff diff proc~hfti->proc~diff proc~ldp->proc~daxpy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~ldp->proc~dcopy proc~ldp->proc~diff proc~nnls nnls proc~ldp->proc~nnls proc~nnls->proc~h12 proc~nnls->proc~diff proc~g1 g1 proc~nnls->proc~g1 var panprocslsqpCallsGraph = svgPanZoom('#procslsqpCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~slsqp~~CalledByGraph proc~slsqp slsqp proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code slsqp Source Code subroutine slsqp ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode , w , l_w , & jw , l_jw , sdat , ldat , alphamin , alphamax ) implicit none integer , intent ( in ) :: m !! is the total number of constraints,  m \\ge 0  integer , intent ( in ) :: meq !! is the number of equality constraints,  m_{eq} \\ge 0  integer , intent ( in ) :: la !! see `a`,  la \\ge \\max(m,1)  integer , intent ( in ) :: n !! is the number of variables,  n \\ge 1  real ( wp ), dimension ( n ), intent ( inout ) :: x !! `x()` stores the current iterate of the `n` vector `x` !! on entry `x()` must be initialized. on exit `x()` !! stores the solution vector `x` if `mode = 0`. real ( wp ), dimension ( n ), intent ( in ) :: xl !! `xl()` stores an n vector of lower bounds `xl` to `x`. real ( wp ), dimension ( n ), intent ( in ) :: xu !! `xu()` stores an n vector of upper bounds `xu` to `x`. real ( wp ), intent ( in ) :: f !! is the value of the objective function. real ( wp ), dimension ( la ), intent ( in ) :: c !! `c()` stores the `m` vector `c` of constraints, !! equality constraints (if any) first. !! dimension of `c` must be greater or equal `la`, !! which must be greater or equal `max(1,m)`. real ( wp ), dimension ( n + 1 ), intent ( in ) :: g !! `g()` stores the `n` vector `g` of partials of the !! objective function; dimension of `g` must be !! greater or equal `n+1`. real ( wp ), dimension ( la , n + 1 ), intent ( in ) :: a !! the `la` by `n + 1` array `a()` stores !! the `m` by `n` matrix `a` of constraint normals. !! `a()` has first dimensioning parameter `la`, !! which must be greater or equal `max(1,m)`. real ( wp ), intent ( inout ) :: acc !! `abs(acc)` controls the final accuracy. !! if `acc` < zero an exact linesearch is performed, !! otherwise an armijo-type linesearch is used. integer , intent ( inout ) :: iter !! prescribes the maximum number of iterations. !! on exit `iter` indicates the number of iterations. integer , intent ( inout ) :: mode !! mode controls calculation: !! !! reverse communication is used in the sense that !! the program is initialized by `mode = 0`; then it is !! to be called repeatedly by the user until a return !! with `mode /= abs(1)` takes place. !! if `mode = -1` gradients have to be calculated, !! while with `mode = 1` functions have to be calculated. !! mode must not be changed between subsequent calls of [[slsqp]]. !! !! **evaluation modes**: !! !! * ** -1 **: gradient evaluation, (`g` & `a`) !! * **  0 **: *on entry*: initialization, (`f`, `g`, `c`, `a`), !!   *on exit*: required accuracy for solution obtained !! * **  1 **: function evaluation, (`f` & `c`) !! !! **failure modes**: !! !! * ** 2 **: number of equality constraints larger than `n` !! * ** 3 **: more than `3*n` iterations in [[lsq]] subproblem !! * ** 4 **: inequality constraints incompatible !! * ** 5 **: singular matrix `e` in [[lsq]] subproblem !! * ** 6 **: singular matrix `c` in [[lsq]] subproblem !! * ** 7 **: rank-deficient equality constraint subproblem [[hfti]] !! * ** 8 **: positive directional derivative for linesearch !! * ** 9 **: more than `iter` iterations in sqp !! * ** >=10 **: working space `w` or `jw` too small, !!   `w` should be enlarged to `l_w=mode/1000`, !!   `jw` should be enlarged to `l_jw=mode-1000*l_w` integer , intent ( in ) :: l_w !! the length of `w`, which should be at least: !! !! * `(3*n1+m)*(n1+1)`                     **for lsq** !! * `+(n1-meq+1)*(mineq+2) + 2*mineq`     **for lsi** !! * `+(n1+mineq)*(n1-meq) + 2*meq + n1`   **for lsei** !! * `+ n1*n/2 + 2*m + 3*n + 3*n1 + 1`     **for slsqpb** !! !! with `mineq = m - meq + 2*n1` & `n1 = n+1` integer , intent ( in ) :: l_jw !! the length of `jw` which should be at least !! `mineq = m - meq + 2*(n+1)`. real ( wp ), dimension ( l_w ), intent ( inout ) :: w !! `w()` is a one dimensional working space. !! the first `m+n+n*n1/2` elements of `w` must not be !! changed between subsequent calls of [[slsqp]]. !! on return `w(1) ... w(m)` contain the multipliers !! associated with the general constraints, while !! `w(m+1) ... w(m+n(n+1)/2)` store the cholesky factor !! `l*d*l(t)` of the approximate hessian of the !! lagrangian columnwise dense as lower triangular !! unit matrix `l` with `d` in its 'diagonal' and !! `w(m+n(n+1)/2+n+2 ... w(m+n(n+1)/2+n+2+m+2n)` !! contain the multipliers associated with all !! constraints of the quadratic program finding !! the search direction to the solution `x*` integer , dimension ( l_jw ), intent ( inout ) :: jw !! `jw()` is a one dimensional integer working space type ( slsqpb_data ), intent ( inout ) :: sdat !! data for [[slsqpb]]. type ( linmin_data ), intent ( inout ) :: ldat !! data for [[linmin]]. real ( wp ), intent ( in ) :: alphamin !! min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: alphamax !! max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  integer :: il , im , ir , is , iu , iv , iw , ix , mineq , n1 !   check length of working arrays n1 = n + 1 mineq = m - meq + n1 + n1 il = ( 3 * n1 + m ) * ( n1 + 1 ) + ( n1 - meq + 1 ) * ( mineq + 2 ) + 2 * mineq + ( n1 + mineq )& * ( n1 - meq ) + 2 * meq + n1 * n / 2 + 2 * m + 3 * n + 4 * n1 + 1 im = max ( mineq , n1 - meq ) if ( l_w < il . or . l_jw < im ) then mode = 1000 * max ( 10 , il ) mode = mode + max ( 10 , im ) return end if if ( meq > n ) then ! note: calling lsq when meq>n is corrupting the ! memory in some way, so just catch this here. mode = 2 return end if !   prepare data for calling sqpbdy  -  initial addresses in w im = 1 il = im + max ( 1 , m ) il = im + la ix = il + n1 * n / 2 + 1 ir = ix + n is = ir + n + n + max ( 1 , m ) is = ir + n + n + la iu = is + n1 iv = iu + n1 iw = iv + n1 sdat % n1 = n1 call slsqpb ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode ,& w ( ir ), w ( il ), w ( ix ), w ( im ), w ( is ), w ( iu ), w ( iv ), w ( iw ), jw ,& sdat % t , sdat % f0 , sdat % h1 , sdat % h2 , sdat % h3 , sdat % h4 ,& sdat % n1 , sdat % n2 , sdat % n3 , sdat % t0 , sdat % gs , sdat % tol , sdat % line ,& sdat % alpha , sdat % iexact , sdat % incons , sdat % ireset , sdat % itermx ,& ldat , alphamin , alphamax ) end subroutine slsqp","tags":"","loc":"proc/slsqp.html","title":"slsqp – slsqp"},{"text":"private subroutine slsqpb(m, meq, la, n, x, xl, xu, f, c, g, a, acc, iter, mode, r, l, x0, mu, s, u, v, w, iw, t, f0, h1, h2, h3, h4, n1, n2, n3, t0, gs, tol, line, alpha, iexact, incons, ireset, itermx, ldat, alphamin, alphamax) nonlinear programming by solving sequentially quadratic programs l1 - line search, positive definite bfgs update Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: meq integer, intent(in) :: la integer, intent(in) :: n real(kind=wp), dimension(n) :: x real(kind=wp), dimension(n) :: xl real(kind=wp), dimension(n) :: xu real(kind=wp) :: f real(kind=wp), dimension(la) :: c real(kind=wp), dimension(n+1) :: g real(kind=wp), dimension(la,n+1) :: a real(kind=wp) :: acc integer, intent(inout) :: iter in: maximum number of iterations. out: actual number of iterations. integer, intent(inout) :: mode real(kind=wp), dimension(m+n+n+2) :: r real(kind=wp), dimension((n+1)*(n+2)/2) :: l real(kind=wp), dimension(n) :: x0 real(kind=wp), dimension(la) :: mu real(kind=wp), dimension(n+1) :: s real(kind=wp), dimension(n+1) :: u real(kind=wp), dimension(n+1) :: v real(kind=wp), intent(inout), dimension(*) :: w dim(w) = n1*(n1+1) + meq*(n1+1) + mineq*(n1+1) for lsq +(n1-meq+1)*(mineq+2) + 2*mineq for lsi +(n1+mineq)*(n1-meq) + 2*meq + n1 for lsei with mineq = m - meq + 2*n1 & n1 = n+1 integer, intent(inout), dimension(*) :: iw real(kind=wp), intent(inout) :: t real(kind=wp), intent(inout) :: f0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(inout) :: h2 real(kind=wp), intent(inout) :: h3 real(kind=wp), intent(inout) :: h4 integer, intent(inout) :: n1 integer, intent(inout) :: n2 integer, intent(inout) :: n3 real(kind=wp), intent(inout) :: t0 real(kind=wp), intent(inout) :: gs real(kind=wp), intent(inout) :: tol integer, intent(inout) :: line real(kind=wp), intent(inout) :: alpha integer, intent(inout) :: iexact integer, intent(inout) :: incons integer, intent(inout) :: ireset integer, intent(inout) :: itermx type( linmin_data ), intent(inout) :: ldat data for linmin . real(kind=wp), intent(in) :: alphamin min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real(kind=wp), intent(in) :: alphamax max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  Calls proc~~slsqpb~~CallsGraph proc~slsqpb slsqpb proc~enforce_bounds enforce_bounds proc~slsqpb->proc~enforce_bounds proc~daxpy daxpy proc~slsqpb->proc~daxpy proc~ldl ldl proc~slsqpb->proc~ldl proc~linmin linmin proc~slsqpb->proc~linmin proc~ddot ddot proc~slsqpb->proc~ddot proc~lsq lsq proc~slsqpb->proc~lsq proc~dscal dscal proc~slsqpb->proc~dscal proc~dnrm2 dnrm2 proc~slsqpb->proc~dnrm2 proc~dcopy dcopy proc~slsqpb->proc~dcopy proc~lsq->proc~enforce_bounds proc~lsq->proc~ddot proc~lsq->proc~dscal proc~lsq->proc~dcopy proc~lsei lsei proc~lsq->proc~lsei proc~lsei->proc~ddot proc~lsei->proc~dnrm2 proc~lsei->proc~dcopy proc~lsi lsi proc~lsei->proc~lsi proc~hfti hfti proc~lsei->proc~hfti proc~h12 h12 proc~lsei->proc~h12 proc~lsi->proc~daxpy proc~lsi->proc~ddot proc~lsi->proc~dnrm2 proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~hfti->proc~h12 proc~diff diff proc~hfti->proc~diff proc~ldp->proc~daxpy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~ldp->proc~dcopy proc~ldp->proc~diff proc~nnls nnls proc~ldp->proc~nnls proc~nnls->proc~h12 proc~nnls->proc~diff proc~g1 g1 proc~nnls->proc~g1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~slsqpb~~CalledByGraph proc~slsqpb slsqpb proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code slsqpb Source Code subroutine slsqpb ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode ,& r , l , x0 , mu , s , u , v , w , iw ,& t , f0 , h1 , h2 , h3 , h4 , n1 , n2 , n3 , t0 , gs , tol , line ,& alpha , iexact , incons , ireset , itermx , ldat ,& alphamin , alphamax ) implicit none integer , intent ( in ) :: m integer , intent ( in ) :: meq integer , intent ( in ) :: la integer , intent ( in ) :: n real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( n ) :: xl real ( wp ), dimension ( n ) :: xu real ( wp ) :: f real ( wp ), dimension ( la ) :: c real ( wp ), dimension ( n + 1 ) :: g real ( wp ), dimension ( la , n + 1 ) :: a real ( wp ) :: acc integer , intent ( inout ) :: iter !! **in:**  maximum number of iterations. !! **out:** actual number of iterations. integer , intent ( inout ) :: mode real ( wp ), dimension ( m + n + n + 2 ) :: r real ( wp ), dimension (( n + 1 ) * ( n + 2 ) / 2 ) :: l real ( wp ), dimension ( n ) :: x0 real ( wp ), dimension ( la ) :: mu real ( wp ), dimension ( n + 1 ) :: s real ( wp ), dimension ( n + 1 ) :: u real ( wp ), dimension ( n + 1 ) :: v real ( wp ), dimension ( * ), intent ( inout ) :: w !! `dim(w)` = !! !! * `n1*(n1+1) + meq*(n1+1) + mineq*(n1+1)`   for [[lsq]] !! * `+(n1-meq+1)*(mineq+2) + 2*mineq`         for [[lsi]] !! * `+(n1+mineq)*(n1-meq) + 2*meq + n1`       for [[lsei]] !! !! with `mineq = m - meq + 2*n1` & `n1 = n+1` integer , dimension ( * ), intent ( inout ) :: iw real ( wp ), intent ( inout ) :: t real ( wp ), intent ( inout ) :: f0 real ( wp ), intent ( inout ) :: h1 real ( wp ), intent ( inout ) :: h2 real ( wp ), intent ( inout ) :: h3 real ( wp ), intent ( inout ) :: h4 integer , intent ( inout ) :: n1 integer , intent ( inout ) :: n2 integer , intent ( inout ) :: n3 real ( wp ), intent ( inout ) :: t0 real ( wp ), intent ( inout ) :: gs real ( wp ), intent ( inout ) :: tol integer , intent ( inout ) :: line real ( wp ), intent ( inout ) :: alpha integer , intent ( inout ) :: iexact integer , intent ( inout ) :: incons integer , intent ( inout ) :: ireset integer , intent ( inout ) :: itermx type ( linmin_data ), intent ( inout ) :: ldat !! data for [[linmin]]. real ( wp ), intent ( in ) :: alphamin !! min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: alphamax !! max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  integer :: i , j , k if ( mode < 0 ) then ! call jacobian at current x ! update cholesky-factors of hessian matrix by modified bfgs formula do i = 1 , n u ( i ) = g ( i ) - ddot ( m , a ( 1 , i ), 1 , r , 1 ) - v ( i ) end do ! l'*s k = 0 do i = 1 , n h1 = zero k = k + 1 do j = i + 1 , n k = k + 1 h1 = h1 + l ( k ) * s ( j ) end do v ( i ) = s ( i ) + h1 end do ! d*l'*s k = 1 do i = 1 , n v ( i ) = l ( k ) * v ( i ) k = k + n1 - i end do ! l*d*l'*s do i = n , 1 , - 1 h1 = zero k = i do j = 1 , i - 1 h1 = h1 + l ( k ) * v ( j ) k = k + n - j end do v ( i ) = v ( i ) + h1 end do h1 = ddot ( n , s , 1 , u , 1 ) h2 = ddot ( n , s , 1 , v , 1 ) h3 = 0.2_wp * h2 if ( h1 < h3 ) then h4 = ( h2 - h3 ) / ( h2 - h1 ) h1 = h3 call dscal ( n , h4 , u , 1 ) call daxpy ( n , one - h4 , v , 1 , u , 1 ) end if call ldl ( n , l , u , + one / h1 , v ) call ldl ( n , l , v , - one / h2 , u ) ! end of main iteration goto 200 else if ( mode == 0 ) then itermx = iter if ( acc >= zero ) then iexact = 0 else iexact = 1 end if acc = abs ( acc ) tol = ten * acc iter = 0 ireset = 0 n1 = n + 1 n2 = n1 * n / 2 n3 = n2 + 1 s ( 1 ) = zero mu ( 1 ) = zero call dcopy ( n , s ( 1 ), 0 , s , 1 ) call dcopy ( m , mu ( 1 ), 0 , mu , 1 ) else ! call functions at current x t = f do j = 1 , m if ( j <= meq ) then h1 = c ( j ) else h1 = zero end if t = t + mu ( j ) * max ( - c ( j ), h1 ) end do h1 = t - t0 if ( iexact + 1 == 1 ) then if ( h1 <= h3 / ten . or . line > 10 ) goto 500 alpha = min ( max ( h3 / ( two * ( h3 - h1 )), alphamin ), alphamax ) goto 300 else if ( iexact + 1 == 2 ) then goto 400 else goto 500 end if end if ! reset bfgs matrix 100 ireset = ireset + 1 if ( ireset > 5 ) then ! check relaxed convergence in case of positive directional derivative if ( ( abs ( f - f0 ) < tol . or . dnrm2 ( n , s , 1 ) < tol ) . and . h3 < tol ) then mode = 0 else mode = 8 end if return else l ( 1 ) = zero call dcopy ( n2 , l ( 1 ), 0 , l , 1 ) j = 1 do i = 1 , n l ( j ) = one j = j + n1 - i end do end if ! main iteration : search direction, steplength, ldl'-update 200 iter = iter + 1 mode = 9 if ( iter > itermx ) return ! search direction as solution of qp - subproblem call dcopy ( n , xl , 1 , u , 1 ) call dcopy ( n , xu , 1 , v , 1 ) call daxpy ( n , - one , x , 1 , u , 1 ) call daxpy ( n , - one , x , 1 , v , 1 ) h4 = one call lsq ( m , meq , n , n3 , la , l , g , a , c , u , v , s , r , w , iw , mode ) ! augmented problem for inconsistent linearization if ( mode == 6 ) then if ( n == meq ) mode = 4 end if if ( mode == 4 ) then do j = 1 , m if ( j <= meq ) then a ( j , n1 ) = - c ( j ) else a ( j , n1 ) = max ( - c ( j ), zero ) end if end do s ( 1 ) = zero call dcopy ( n , s ( 1 ), 0 , s , 1 ) h3 = zero g ( n1 ) = zero l ( n3 ) = hun s ( n1 ) = one u ( n1 ) = zero v ( n1 ) = one incons = 0 250 call lsq ( m , meq , n1 , n3 , la , l , g , a , c , u , v , s , r , w , iw , mode ) h4 = one - s ( n1 ) if ( mode == 4 ) then l ( n3 ) = ten * l ( n3 ) incons = incons + 1 if ( incons <= 5 ) goto 250 return else if ( mode /= 1 ) then return end if else if ( mode /= 1 ) then return end if ! update multipliers for l1-test do i = 1 , n v ( i ) = g ( i ) - ddot ( m , a ( 1 , i ), 1 , r , 1 ) end do f0 = f call dcopy ( n , x , 1 , x0 , 1 ) gs = ddot ( n , g , 1 , s , 1 ) h1 = abs ( gs ) h2 = zero do j = 1 , m if ( j <= meq ) then h3 = c ( j ) else h3 = zero end if h2 = h2 + max ( - c ( j ), h3 ) h3 = abs ( r ( j )) mu ( j ) = max ( h3 ,( mu ( j ) + h3 ) / two ) h1 = h1 + h3 * abs ( c ( j )) end do ! check convergence mode = 0 if ( h1 < acc . and . h2 < acc ) return h1 = zero do j = 1 , m if ( j <= meq ) then h3 = c ( j ) else h3 = zero end if h1 = h1 + mu ( j ) * max ( - c ( j ), h3 ) end do t0 = f + h1 h3 = gs - h1 * h4 mode = 8 if ( h3 >= zero ) goto 100 ! line search with an l1-testfunction line = 0 alpha = alphamax if ( iexact == 1 ) goto 400 ! inexact linesearch 300 line = line + 1 h3 = alpha * h3 call dscal ( n , alpha , s , 1 ) call dcopy ( n , x0 , 1 , x , 1 ) call daxpy ( n , one , s , 1 , x , 1 ) call enforce_bounds ( x , xl , xu ) ! ensure that x doesn't violate bounds mode = 1 return ! exact linesearch 400 if ( line /= 3 ) then alpha = linmin ( line , alphamin , alphamax , t , tol , & ldat % a , ldat % b , ldat % d , ldat % e , ldat % p , ldat % q , & ldat % r , ldat % u , ldat % v , ldat % w , ldat % x , ldat % m , & ldat % fu , ldat % fv , ldat % fw , ldat % fx , ldat % tol1 , ldat % tol2 ) call dcopy ( n , x0 , 1 , x , 1 ) call daxpy ( n , alpha , s , 1 , x , 1 ) mode = 1 return end if call dscal ( n , alpha , s , 1 ) ! check convergence 500 h3 = zero do j = 1 , m if ( j <= meq ) then h1 = c ( j ) else h1 = zero end if h3 = h3 + max ( - c ( j ), h1 ) end do if ( ( abs ( f - f0 ) < acc . or . dnrm2 ( n , s , 1 ) < acc ) . and . h3 < acc ) then mode = 0 else mode = - 1 end if end subroutine slsqpb","tags":"","loc":"proc/slsqpb.html","title":"slsqpb – slsqp"},{"text":"private subroutine lsq(m, meq, n, nl, la, l, g, a, b, xl, xu, x, y, w, jw, mode) Minimize  || e x - f ||  with respect to x,\n  with upper triangular matrix  e = + d &#94;{1/2} l&#94;T ,\n  and vector  f = -d&#94;{-1/2} l&#94;{-1} g ,\n  where the unit lower tridiangular matrix l is stored columnwise\n  dense in the n*(n+1)/2 array l with vector d stored in its\n  'diagonal' thus substituting the one-elements of l subject to:  a(j)*x - b(j) = 0,              j=1,...,meq  ,  a(j)*x - b(j) \\ge 0,            j=meq+1,...,m,  x_l(i) \\le x(i) \\le x_u(i),     i=1,...,n    , On entry, the user has to provide the arrays l , g , a , b , xl , xu .\n  with dimensions: l(n*(n+1)/2) , g(n) , a(la,n) , b(m) , xl(n) , xu(n) . The working array w must have at least the following dimension: dim(w) = (3*n+m)*(n+1) for lsq +(n-meq+1)*(mineq+2) + 2*mineq for lsi +(n+mineq)*(n-meq) + 2*meq + n for lsei with mineq = m - meq + 2*n On return, no array will be changed by the subroutine. History coded dieter kraft, april 1987 revised march 1989 Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: meq integer, intent(in) :: n integer, intent(in) :: nl integer, intent(in) :: la real(kind=wp), dimension(nl) :: l real(kind=wp), dimension(n) :: g real(kind=wp), dimension(la,n) :: a real(kind=wp), dimension(la) :: b real(kind=wp), dimension(n) :: xl real(kind=wp), dimension(n) :: xu real(kind=wp), dimension(n) :: x stores the n-dimensional solution vector real(kind=wp), dimension(m+n+n) :: y stores the vector of lagrange multipliers of dimension\n m+n+n (constraints+lower+upper bounds) real(kind=wp), dimension(*) :: w integer, dimension(*) :: jw integer :: mode is a success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<1 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible, 5: matrix e is not of full rank, 6: matrix c is not of full rank, 7: rank defect in hfti Calls proc~~lsq~~CallsGraph proc~lsq lsq proc~enforce_bounds enforce_bounds proc~lsq->proc~enforce_bounds proc~dscal dscal proc~lsq->proc~dscal proc~lsei lsei proc~lsq->proc~lsei proc~dcopy dcopy proc~lsq->proc~dcopy proc~ddot ddot proc~lsq->proc~ddot proc~lsei->proc~dcopy proc~lsei->proc~ddot proc~lsi lsi proc~lsei->proc~lsi proc~hfti hfti proc~lsei->proc~hfti proc~h12 h12 proc~lsei->proc~h12 proc~dnrm2 dnrm2 proc~lsei->proc~dnrm2 proc~lsi->proc~ddot proc~lsi->proc~h12 proc~lsi->proc~dnrm2 proc~daxpy daxpy proc~lsi->proc~daxpy proc~ldp ldp proc~lsi->proc~ldp proc~hfti->proc~h12 proc~diff diff proc~hfti->proc~diff proc~ldp->proc~dcopy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~ldp->proc~daxpy proc~ldp->proc~diff proc~nnls nnls proc~ldp->proc~nnls proc~nnls->proc~h12 proc~nnls->proc~diff proc~g1 g1 proc~nnls->proc~g1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~lsq~~CalledByGraph proc~lsq lsq proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lsq Source Code subroutine lsq ( m , meq , n , nl , la , l , g , a , b , xl , xu , x , y , w , jw , mode ) implicit none integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: meq integer , intent ( in ) :: nl integer , intent ( in ) :: la real ( wp ), dimension ( n ) :: x !! stores the n-dimensional solution vector real ( wp ), dimension ( m + n + n ) :: y !! stores the vector of lagrange multipliers of dimension !! m+n+n (constraints+lower+upper bounds) integer :: mode !! is a success-failure flag with the following meanings: !! !! * **1:** successful computation, !! * **2:** error return because of wrong dimensions (`n<1`), !! * **3:** iteration count exceeded by [[nnls]], !! * **4:** inequality constraints incompatible, !! * **5:** matrix `e` is not of full rank, !! * **6:** matrix `c` is not of full rank, !! * **7:** rank defect in [[hfti]] real ( wp ), dimension ( nl ) :: l real ( wp ), dimension ( n ) :: g real ( wp ), dimension ( la , n ) :: a real ( wp ), dimension ( la ) :: b real ( wp ), dimension ( * ) :: w real ( wp ), dimension ( n ) :: xl real ( wp ), dimension ( n ) :: xu integer , dimension ( * ) :: jw real ( wp ) :: diag , xnorm integer :: i , ic , id , ie , if , ig , ih , il , im , ip , & iu , iw , i1 , i2 , i3 , i4 , mineq , & m1 , n1 , n2 , n3 n1 = n + 1 mineq = m - meq m1 = mineq + n + n !  determine whether to solve problem !  with inconsistent linerarization (n2=1) !  or not (n2=0) n2 = n1 * n / 2 + 1 if ( n2 == nl ) then n2 = 0 else n2 = 1 end if n3 = n - n2 !  recover matrix e and vector f from l and g i2 = 1 i3 = 1 i4 = 1 ie = 1 if = n * n + 1 do i = 1 , n3 i1 = n1 - i diag = sqrt ( l ( i2 )) w ( i3 ) = zero call dcopy ( i1 , w ( i3 ), 0 , w ( i3 ), 1 ) call dcopy ( i1 - n2 , l ( i2 ), 1 , w ( i3 ), n ) call dscal ( i1 - n2 , diag , w ( i3 ), n ) w ( i3 ) = diag w ( if - 1 + i ) = ( g ( i ) - ddot ( i - 1 , w ( i4 ), 1 , w ( if ), 1 )) / diag i2 = i2 + i1 - n2 i3 = i3 + n1 i4 = i4 + n end do if ( n2 == 1 ) then w ( i3 ) = l ( nl ) w ( i4 ) = zero call dcopy ( n3 , w ( i4 ), 0 , w ( i4 ), 1 ) w ( if - 1 + n ) = zero end if call dscal ( n , - one , w ( if ), 1 ) ic = if + n id = ic + meq * n if ( meq > 0 ) then !  recover matrix c from upper part of a do i = 1 , meq call dcopy ( n , a ( i , 1 ), la , w ( ic - 1 + i ), meq ) end do !  recover vector d from upper part of b call dcopy ( meq , b ( 1 ), 1 , w ( id ), 1 ) call dscal ( meq , - one , w ( id ), 1 ) end if ig = id + meq if ( mineq > 0 ) then !  recover matrix g from lower part of a do i = 1 , mineq call dcopy ( n , a ( meq + i , 1 ), la , w ( ig - 1 + i ), m1 ) end do end if !  augment matrix g by +i and -i ip = ig + mineq do i = 1 , n w ( ip - 1 + i ) = zero call dcopy ( n , w ( ip - 1 + i ), 0 , w ( ip - 1 + i ), m1 ) end do w ( ip ) = one call dcopy ( n , w ( ip ), 0 , w ( ip ), m1 + 1 ) im = ip + n do i = 1 , n w ( im - 1 + i ) = zero call dcopy ( n , w ( im - 1 + i ), 0 , w ( im - 1 + i ), m1 ) end do w ( im ) = - one call dcopy ( n , w ( im ), 0 , w ( im ), m1 + 1 ) ih = ig + m1 * n if ( mineq > 0 ) then ! recover h from lower part of b call dcopy ( mineq , b ( meq + 1 ), 1 , w ( ih ), 1 ) call dscal ( mineq , - one , w ( ih ), 1 ) end if !  augment vector h by xl and xu il = ih + mineq call dcopy ( n , xl , 1 , w ( il ), 1 ) iu = il + n call dcopy ( n , xu , 1 , w ( iu ), 1 ) call dscal ( n , - one , w ( iu ), 1 ) iw = iu + n call lsei ( w ( ic ), w ( id ), w ( ie ), w ( if ), w ( ig ), w ( ih ), max ( 1 , meq ), meq , n , n , & m1 , m1 , n , x , xnorm , w ( iw ), jw , mode ) if ( mode == 1 ) then ! restore lagrange multipliers call dcopy ( m , w ( iw ), 1 , y ( 1 ), 1 ) call dcopy ( n3 , w ( iw + m ), 1 , y ( m + 1 ), 1 ) call dcopy ( n3 , w ( iw + m + n ), 1 , y ( m + n3 + 1 ), 1 ) call enforce_bounds ( x , xl , xu ) ! to ensure that bounds are not violated end if end subroutine lsq","tags":"","loc":"proc/lsq.html","title":"lsq – slsqp"},{"text":"private subroutine lsei(c, d, e, f, g, h, lc, mc, le, me, lg, mg, n, x, xnrm, w, jw, mode) for mode=1 , the subroutine returns the solution x of\n  equality & inequality constrained least squares problem lsei :  \\underset{x}{\\min} ||E x - f||  s.t.   C x  = d   and  G x \\ge h . using QR decomposition & orthogonal basis of nullspace of  C . The following dimensions of the arrays defining the problem\n  are necessary: dim(c) :   formal (lc,n),    actual (mc,n)\n        dim(d) :   formal (lc  ),    actual (mc  )\n        dim(e) :   formal (le,n),    actual (me,n)\n        dim(f) :   formal (le  ),    actual (me  )\n        dim(g) :   formal (lg,n),    actual (mg,n)\n        dim(h) :   formal (lg  ),    actual (mg  )\n        dim(x) :   formal (n   ),    actual (n   )\n        dim(w) :   2*mc+me+(me+mg)*(n-mc)  for lsei\n                 +(n-mc+1)*(mg+2)+2*mg     for lsi\n        dim(jw):   max(mg,l) On entry, the user has to provide the arrays C, d, E, f, G, and h.\n  On return, all arrays will be changed by the subroutine. Reference Chapter 23.6 of Lawson & Hanson: Solving least squares problems. History 18.5.1981, dieter kraft, dfvlr oberpfaffenhofen 20.3.1987, dieter kraft, dfvlr oberpfaffenhofen Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(lc,n) :: c real(kind=wp), intent(inout), dimension(lc) :: d real(kind=wp), intent(inout), dimension(le,n) :: e real(kind=wp), intent(inout), dimension(le) :: f real(kind=wp), intent(inout), dimension(lg,n) :: g real(kind=wp), intent(inout), dimension(lg) :: h integer, intent(in) :: lc integer, intent(in) :: mc integer, intent(in) :: le integer, intent(in) :: me integer, intent(in) :: lg integer, intent(in) :: mg integer, intent(in) :: n real(kind=wp), intent(out), dimension(n) :: x stores the solution vector real(kind=wp), intent(out) :: xnrm stores the residuum of the solution in euclidian norm real(kind=wp), intent(inout), dimension(*) :: w on return, stores the vector of lagrange multipliers\n in its first mc+mg elements integer, intent(inout), dimension(*) :: jw integer, intent(out) :: mode is a success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<1 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible, 5: matrix e is not of full rank, 6: matrix c is not of full rank, 7: rank defect in hfti Calls proc~~lsei~~CallsGraph proc~lsei lsei proc~lsi lsi proc~lsei->proc~lsi proc~hfti hfti proc~lsei->proc~hfti proc~ddot ddot proc~lsei->proc~ddot proc~h12 h12 proc~lsei->proc~h12 proc~dnrm2 dnrm2 proc~lsei->proc~dnrm2 proc~dcopy dcopy proc~lsei->proc~dcopy proc~lsi->proc~ddot proc~lsi->proc~h12 proc~lsi->proc~dnrm2 proc~daxpy daxpy proc~lsi->proc~daxpy proc~ldp ldp proc~lsi->proc~ldp proc~hfti->proc~h12 proc~diff diff proc~hfti->proc~diff proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~ldp->proc~dcopy proc~ldp->proc~daxpy proc~ldp->proc~diff proc~nnls nnls proc~ldp->proc~nnls proc~nnls->proc~h12 proc~nnls->proc~diff proc~g1 g1 proc~nnls->proc~g1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~lsei~~CalledByGraph proc~lsei lsei proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lsei Source Code subroutine lsei ( c , d , e , f , g , h , lc , mc , le , me , lg , mg , n , x , xnrm , w , jw , mode ) implicit none integer , intent ( in ) :: lc integer , intent ( in ) :: mc integer , intent ( in ) :: le integer , intent ( in ) :: me integer , intent ( in ) :: lg integer , intent ( in ) :: mg integer , intent ( in ) :: n real ( wp ), dimension ( lc , n ), intent ( inout ) :: c real ( wp ), dimension ( lc ) , intent ( inout ) :: d real ( wp ), dimension ( le , n ), intent ( inout ) :: e real ( wp ), dimension ( le ) , intent ( inout ) :: f real ( wp ), dimension ( lg , n ), intent ( inout ) :: g real ( wp ), dimension ( lg ) , intent ( inout ) :: h real ( wp ), dimension ( n ) , intent ( out ) :: x !! stores the solution vector real ( wp ), intent ( out ) :: xnrm !! stores the residuum of the solution in euclidian norm real ( wp ), dimension ( * ) , intent ( inout ) :: w !! on return, stores the vector of lagrange multipliers !! in its first `mc+mg` elements integer , dimension ( * ) , intent ( inout ) :: jw integer , intent ( out ) :: mode !! is a success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<1`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible, !! * ***5:*** matrix `e` is not of full rank, !! * ***6:*** matrix `c` is not of full rank, !! * ***7:*** rank defect in [[hfti]] integer :: i , ie , if , ig , iw , j , k , krank , l , mc1 real ( wp ) :: t , dum ( 1 ) mode = 2 if ( mc <= n ) then l = n - mc mc1 = mc + 1 iw = ( l + 1 ) * ( mg + 2 ) + 2 * mg + mc ie = iw + mc + 1 if = ie + me * l ig = if + me !  triangularize c and apply factors to e and g do i = 1 , mc j = min ( i + 1 , lc ) call h12 ( 1 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), c ( j , 1 ), lc , 1 , mc - i ) call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), e , le , 1 , me ) call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), g , lg , 1 , mg ) end do !  solve c*x=d and modify f mode = 6 do i = 1 , mc if ( abs ( c ( i , i )) < epmach ) return x ( i ) = ( d ( i ) - ddot ( i - 1 , c ( i , 1 ), lc , x , 1 )) / c ( i , i ) end do mode = 1 w ( mc1 ) = zero !call dcopy(mg-mc,w(mc1),0,w(mc1),1)  ! original code call dcopy ( mg , w ( mc1 ), 0 , w ( mc1 ), 1 ) ! bug fix for when meq = n if ( mc /= n ) then do i = 1 , me w ( if - 1 + i ) = f ( i ) - ddot ( mc , e ( i , 1 ), le , x , 1 ) end do !  store transformed e & g do i = 1 , me call dcopy ( l , e ( i , mc1 ), le , w ( ie - 1 + i ), me ) end do do i = 1 , mg call dcopy ( l , g ( i , mc1 ), lg , w ( ig - 1 + i ), mg ) end do if ( mg > 0 ) then !  modify h and solve inequality constrained ls problem do i = 1 , mg h ( i ) = h ( i ) - ddot ( mc , g ( i , 1 ), lg , x , 1 ) end do call lsi ( w ( ie ), w ( if ), w ( ig ), h , me , me , mg , mg , l , x ( mc1 ), xnrm , & w ( mc1 ), jw , mode ) if ( mc == 0 ) return t = dnrm2 ( mc , x , 1 ) xnrm = sqrt ( xnrm * xnrm + t * t ) if ( mode /= 1 ) return else ! solve ls without inequality constraints mode = 7 k = max ( le , n ) t = sqrt ( epmach ) call hfti ( w ( ie ), me , me , l , w ( if ), k , 1 , t , krank , dum , w , w ( l + 1 ), jw ) xnrm = dum ( 1 ) call dcopy ( l , w ( if ), 1 , x ( mc1 ), 1 ) if ( krank /= l ) return mode = 1 end if end if !  solution of original problem and lagrange multipliers do i = 1 , me f ( i ) = ddot ( n , e ( i , 1 ), le , x , 1 ) - f ( i ) end do do i = 1 , mc d ( i ) = ddot ( me , e ( 1 , i ), 1 , f , 1 ) & - ddot ( mg , g ( 1 , i ), 1 , w ( mc1 ), 1 ) end do do i = mc , 1 , - 1 call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), x , 1 , 1 , 1 ) end do do i = mc , 1 , - 1 j = min ( i + 1 , lc ) w ( i ) = ( d ( i ) - ddot ( mc - i , c ( j , i ), 1 , w ( j ), 1 )) / c ( i , i ) end do end if end subroutine lsei","tags":"","loc":"proc/lsei.html","title":"lsei – slsqp"},{"text":"private subroutine lsi(e, f, g, h, le, me, lg, mg, n, x, xnorm, w, jw, mode) for mode=1 , the subroutine returns the solution x of\n  inequality constrained linear least squares problem:  \\underset{x}{\\min} ||E x - f||  s.t.  G x \\ge h . the following dimensions of the arrays defining the problem\n  are necessary: dim(e) :   formal (le,n),    actual (me,n)\n     dim(f) :   formal (le  ),    actual (me  )\n     dim(g) :   formal (lg,n),    actual (mg,n)\n     dim(h) :   formal (lg  ),    actual (mg  )\n     dim(x) :   n\n     dim(w) :   (n+1)*(mg+2) + 2*mg\n     dim(jw):   lg on entry, the user has to provide the arrays e , f , g , and h .\n  on return, all arrays will be changed by the subroutine. Reference Chapter 23.6 of Lawson & Hanson: Solving least squares problems. History 03.01.1980, dieter kraft: coded 20.03.1987, dieter kraft: revised to fortran 77 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(le,n) :: e real(kind=wp), intent(inout), dimension(le) :: f real(kind=wp), intent(inout), dimension(lg,n) :: g real(kind=wp), intent(inout), dimension(lg) :: h integer, intent(in) :: le integer, intent(in) :: me integer, intent(in) :: lg integer, intent(in) :: mg integer, intent(in) :: n real(kind=wp), intent(out), dimension(n) :: x stores the solution vector real(kind=wp), intent(out) :: xnorm stores the residuum of the solution in euclidian norm real(kind=wp), intent(inout), dimension(*) :: w stores the vector of lagrange multipliers in its first mg elements integer, intent(inout), dimension(lg) :: jw integer, intent(out) :: mode is a success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<1 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible, 5: matrix e is not of full rank. Calls proc~~lsi~~CallsGraph proc~lsi lsi proc~ddot ddot proc~lsi->proc~ddot proc~dnrm2 dnrm2 proc~lsi->proc~dnrm2 proc~daxpy daxpy proc~lsi->proc~daxpy proc~h12 h12 proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~ldp->proc~daxpy proc~diff diff proc~ldp->proc~diff proc~nnls nnls proc~ldp->proc~nnls proc~dcopy dcopy proc~ldp->proc~dcopy proc~nnls->proc~h12 proc~nnls->proc~diff proc~g1 g1 proc~nnls->proc~g1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~lsi~~CalledByGraph proc~lsi lsi proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code lsi Source Code subroutine lsi ( e , f , g , h , le , me , lg , mg , n , x , xnorm , w , jw , mode ) implicit none integer , intent ( in ) :: le integer , intent ( in ) :: me integer , intent ( in ) :: lg integer , intent ( in ) :: mg integer , intent ( in ) :: n real ( wp ), dimension ( le , n ), intent ( inout ) :: e real ( wp ), dimension ( le ) , intent ( inout ) :: f real ( wp ), dimension ( lg , n ), intent ( inout ) :: g real ( wp ), dimension ( lg ) , intent ( inout ) :: h real ( wp ), dimension ( n ) , intent ( out ) :: x !! stores the solution vector real ( wp ), intent ( out ) :: xnorm !! stores the residuum of the solution in euclidian norm real ( wp ), dimension ( * ) , intent ( inout ) :: w !! stores the vector of lagrange multipliers in its first !! `mg` elements integer , dimension ( lg ) , intent ( inout ) :: jw integer , intent ( out ) :: mode !! is a success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<1`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible, !! * ***5:*** matrix `e` is not of full rank. integer :: i , j real ( wp ) :: t !  qr-factors of e and application to f do i = 1 , n j = min ( i + 1 , n ) call h12 ( 1 , i , i + 1 , me , e ( 1 , i ), 1 , t , e ( 1 , j ), 1 , le , n - i ) call h12 ( 2 , i , i + 1 , me , e ( 1 , i ), 1 , t , f , 1 , 1 , 1 ) end do !  transform g and h to get least distance problem mode = 5 do i = 1 , mg do j = 1 , n if ( abs ( e ( j , j )) < epmach ) return g ( i , j ) = ( g ( i , j ) - ddot ( j - 1 , g ( i , 1 ), lg , e ( 1 , j ), 1 )) / e ( j , j ) end do h ( i ) = h ( i ) - ddot ( n , g ( i , 1 ), lg , f , 1 ) end do !  solve least distance problem call ldp ( g , lg , mg , n , h , x , xnorm , w , jw , mode ) if ( mode == 1 ) then !  solution of original problem call daxpy ( n , one , f , 1 , x , 1 ) do i = n , 1 , - 1 j = min ( i + 1 , n ) x ( i ) = ( x ( i ) - ddot ( n - i , e ( i , j ), le , x ( j ), 1 )) / e ( i , i ) end do j = min ( n + 1 , me ) t = dnrm2 ( me - n , f ( j ), 1 ) xnorm = sqrt ( xnorm * xnorm + t * t ) end if end subroutine lsi","tags":"","loc":"proc/lsi.html","title":"lsi – slsqp"},{"text":"private subroutine ldp(g, mg, m, n, h, x, xnorm, w, index, mode) Least distance programming routine.\n  Minimize  \\frac{1}{2} \\mathbf{x}&#94;T \\mathbf{x}   subject to\n   \\mathbf{G} \\mathbf{x} \\ge \\mathbf{h} . The declared dimension of w must be at least (n+1)*(m+2)+2*m : first (n+1)*m locs of w = matrix e for problem nnls.\n       next      n+1 locs of w = vector f for problem nnls.\n       next      n+1 locs of w = vector z for problem nnls.\n       next        m locs of w = vector y for problem nnls.\n       next        m locs of w = vector wdual for problem nnls. References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Note The 1995 version of this routine may have some sort of problem.\n      Using a refactored version of the original routine. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(mg,n) :: g on entry g stores the m by n matrix of\n linear inequality constraints. g has first\n dimensioning parameter mg integer, intent(in) :: mg integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in), dimension(m) :: h the right side of the inequality system. real(kind=wp), intent(out), dimension(n) :: x solution vector x if mode=1 . real(kind=wp), intent(out) :: xnorm euclidian norm of the solution vector\n if computation is successful real(kind=wp), intent(inout), dimension(*) :: w w is a one dimensional working space, the length\n of which should be at least (m+2)*(n+1) + 2*m .\n on exit w stores the lagrange multipliers\n associated with the constraints.\n at the solution of problem ldp . integer, intent(inout), dimension(m) :: index integer working space integer, intent(out) :: mode success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<=0 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible. Calls proc~~ldp~~CallsGraph proc~ldp ldp proc~diff diff proc~ldp->proc~diff proc~daxpy daxpy proc~ldp->proc~daxpy proc~ddot ddot proc~ldp->proc~ddot proc~nnls nnls proc~ldp->proc~nnls proc~dnrm2 dnrm2 proc~ldp->proc~dnrm2 proc~dcopy dcopy proc~ldp->proc~dcopy proc~nnls->proc~diff proc~h12 h12 proc~nnls->proc~h12 proc~g1 g1 proc~nnls->proc~g1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~ldp~~CalledByGraph proc~ldp ldp proc~lsi lsi proc~lsi->proc~ldp proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ldp Source Code subroutine ldp ( g , mg , m , n , h , x , xnorm , w , index , mode ) implicit none integer , intent ( in ) :: mg integer , intent ( in ) :: m integer , intent ( in ) :: n real ( wp ), dimension ( mg , n ), intent ( in ) :: g !! on entry `g` stores the `m` by `n` matrix of !! linear inequality constraints. `g` has first !! dimensioning parameter `mg` real ( wp ), dimension ( m ), intent ( in ) :: h !! the right side of the inequality system. real ( wp ), dimension ( n ), intent ( out ) :: x !! solution vector `x` if `mode=1`. real ( wp ), dimension ( * ), intent ( inout ) :: w !! `w` is a one dimensional working space, the length !! of which should be at least `(m+2)*(n+1) + 2*m`. !! on exit `w` stores the lagrange multipliers !! associated with the constraints. !! at the solution of problem `ldp`. integer , dimension ( m ), intent ( inout ) :: index !! integer working space real ( wp ), intent ( out ) :: xnorm !! euclidian norm of the solution vector !! if computation is successful integer , intent ( out ) :: mode !! success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<=0`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible. integer :: i , iw , iwdual , iy , iz , j , jf , n1 real ( wp ) :: fac , rnorm if ( n <= 0 ) then ! error return. mode = 2 else ! state dual problem mode = 1 x = zero xnorm = zero if ( m /= 0 ) then iw = 0 do j = 1 , m do i = 1 , n iw = iw + 1 w ( iw ) = g ( j , i ) end do iw = iw + 1 w ( iw ) = h ( j ) end do jf = iw + 1 do i = 1 , n iw = iw + 1 w ( iw ) = zero end do w ( iw + 1 ) = one n1 = n + 1 iz = iw + 2 iy = iz + n1 iwdual = iy + m ! solve dual problem call nnls ( w , n1 , n1 , m , w ( jf ), w ( iy ), rnorm , w ( iwdual ), w ( iz ), index , mode ) if ( mode == 1 ) then mode = 4 if ( rnorm > zero ) then !  compute solution of primal problem fac = one - ddot ( m , h , 1 , w ( iy ), 1 ) if ( diff ( one + fac , one ) > zero ) then mode = 1 fac = one / fac do j = 1 , n x ( j ) = fac * ddot ( m , g ( 1 , j ), 1 , w ( iy ), 1 ) end do xnorm = dnrm2 ( n , x , 1 ) ! compute lagrange multipliers for primal problem w ( 1 ) = zero call dcopy ( m , w ( 1 ), 0 , w , 1 ) call daxpy ( m , fac , w ( iy ), 1 , w , 1 ) end if end if end if end if end if end subroutine ldp","tags":"","loc":"proc/ldp.html","title":"ldp – slsqp"},{"text":"private subroutine nnls(a, mda, m, n, b, x, rnorm, w, zz, index, mode) Nonnegative least squares algorithm. Given an m by n matrix, \\mathbf{A}, and an m-vector, \\mathbf{b},\n  compute an n-vector, \\mathbf{x}, that solves the least squares problem:  \\mathbf{A} \\mathbf{x} = \\mathbf{b} subject to  \\mathbf{x} \\ge 0  References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a on entry, contains the m by n matrix, a . on exit, contains\n the product matrix, q*a , where q is an m by m orthogonal matrix generated implicitly by\n this subroutine. integer, intent(in) :: mda first dimensioning parameter for the array a . integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(m) :: b on entry, contains the m-vector b . on exit, contains q*b . real(kind=wp), intent(out), dimension(n) :: x the solution vector. real(kind=wp), intent(out) :: rnorm euclidean norm of the residual vector. real(kind=wp), intent(inout), dimension(n) :: w array of working space.  on exit w will contain\n the dual solution vector. w will satisfy w(i) = 0 for all i in set p and w(i) <= 0 for all i in set z . real(kind=wp), intent(inout), dimension(m) :: zz an m-array of working space. integer, intent(out), dimension(n) :: index an integer working array.\n on exit the contents of this array define the sets p and z as follows: index(1:nsetp) = set p . index(iz1:iz2) = set z . where: iz1 = nsetp + 1 = npp1 , iz2 = n integer, intent(out) :: mode this is a success-failure flag with the following meanings: 1 the solution has been computed successfully. 2 the dimensions of the problem are bad. either m<=0 or n<=0 . 3 iteration count exceeded. more than 3*n iterations. Calls proc~~nnls~~CallsGraph proc~nnls nnls proc~diff diff proc~nnls->proc~diff proc~h12 h12 proc~nnls->proc~h12 proc~g1 g1 proc~nnls->proc~g1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~nnls~~CalledByGraph proc~nnls nnls proc~ldp ldp proc~ldp->proc~nnls proc~lsi lsi proc~lsi->proc~ldp proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp var panprocnnlsCalledByGraph = svgPanZoom('#procnnlsCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code nnls Source Code subroutine nnls ( a , mda , m , n , b , x , rnorm , w , zz , index , mode ) implicit none integer , intent ( in ) :: mda !! first dimensioning parameter for the array `a`. integer , intent ( in ) :: n real ( wp ), dimension ( mda , n ), intent ( inout ) :: a !! on entry, contains the `m` by `n` !! matrix, `a`. on exit, contains !! the product matrix, `q*a`, where `q` is an !! `m` by `m` orthogonal matrix generated implicitly by !! this subroutine. integer , intent ( in ) :: m real ( wp ), dimension ( m ), intent ( inout ) :: b !! on entry, contains the m-vector `b`. on exit, contains `q*b`. real ( wp ), dimension ( n ), intent ( out ) :: x !! the solution vector. real ( wp ), intent ( out ) :: rnorm !! euclidean norm of the residual vector. real ( wp ), dimension ( n ), intent ( inout ) :: w !! array of working space.  on exit `w` will contain !! the dual solution vector. `w` will satisfy `w(i) = 0` !! for all `i` in set `p` and `w(i) <= 0` for all `i` in set `z`. real ( wp ), dimension ( m ), intent ( inout ) :: zz !! an m-array of working space. integer , dimension ( n ), intent ( out ) :: index !! an integer working array. !! on exit the contents of this array define the sets !! `p` and `z` as follows: !! !! * `index(1:nsetp) = set p`. !! * `index(iz1:iz2) = set z`. !! !! where: `iz1 = nsetp + 1 = npp1`, `iz2 = n` integer , intent ( out ) :: mode !! this is a success-failure flag with the following meanings: !! !! * ***1*** the solution has been computed successfully. !! * ***2*** the dimensions of the problem are bad. either `m<=0` or `n<=0`. !! * ***3*** iteration count exceeded. more than `3*n` iterations. integer :: i , ii , ip , iter , itmax , iz , iz1 , iz2 , izmax , j , jj , jz , l , npp1 , nsetp , rtnkey real ( wp ) :: alpha , asave , cc , sm , ss , t , temp , unorm , up , wmax , ztest real ( wp ), dimension ( 1 ) :: dummy real ( wp ), parameter :: factor = 0.01_wp mode = 1 if ( m <= 0 . or . n <= 0 ) then mode = 2 return end if iter = 0 itmax = 3 * n ! initialize the arrays index() and x(). do i = 1 , n x ( i ) = zero index ( i ) = i end do iz2 = n iz1 = 1 nsetp = 0 npp1 = 1 ! ******  main loop begins here  ****** ! quit if all coefficients are already in the solution. ! or if m cols of a have been triangularized. 100 if ( iz1 <= iz2 . and . nsetp < m ) then ! compute components of the dual (negative gradient) vector w(). do iz = iz1 , iz2 j = index ( iz ) sm = zero do l = npp1 , m sm = sm + a ( l , j ) * b ( l ) end do w ( j ) = sm end do ! find largest positive w(j). 150 wmax = zero do iz = iz1 , iz2 j = index ( iz ) if ( w ( j ) > wmax ) then wmax = w ( j ) izmax = iz end if end do ! if wmax <= 0. go to termination. ! this indicates satisfaction of the kuhn-tucker conditions. if ( wmax > zero ) then iz = izmax j = index ( iz ) ! the sign of w(j) is ok for j to be moved to set p. ! begin the transformation and check new diagonal element to avoid ! near linear dependence. asave = a ( npp1 , j ) call h12 ( 1 , npp1 , npp1 + 1 , m , a ( 1 , j ), 1 , up , dummy , 1 , 1 , 0 ) unorm = zero if ( nsetp /= 0 ) then do l = 1 , nsetp unorm = unorm + a ( l , j ) ** 2 end do end if unorm = sqrt ( unorm ) if ( diff ( unorm + abs ( a ( npp1 , j )) * factor , unorm ) > zero ) then ! col j is sufficiently independent.  copy b into zz, update zz ! and solve for ztest ( = proposed new value for x(j) ). do l = 1 , m zz ( l ) = b ( l ) end do call h12 ( 2 , npp1 , npp1 + 1 , m , a ( 1 , j ), 1 , up , zz , 1 , 1 , 1 ) ztest = zz ( npp1 ) / a ( npp1 , j ) ! see if ztest is positive if ( ztest > zero ) then ! the index j=index(iz) has been selected to be moved from ! set z to set p. update b, update indices, apply householder ! transformations to cols in new set z, zero subdiagonal elts in ! col j, set w(j)=0. do l = 1 , m b ( l ) = zz ( l ) end do index ( iz ) = index ( iz1 ) index ( iz1 ) = j iz1 = iz1 + 1 nsetp = npp1 npp1 = npp1 + 1 if ( iz1 <= iz2 ) then do jz = iz1 , iz2 jj = index ( jz ) call h12 ( 2 , nsetp , npp1 , m , a ( 1 , j ), 1 , up , a ( 1 , jj ), 1 , mda , 1 ) end do end if if ( nsetp /= m ) then do l = npp1 , m a ( l , j ) = zero end do end if w ( j ) = zero ! solve the triangular system. ! store the solution temporarily in zz(). rtnkey = 1 goto 300 end if end if ! reject j as a candidate to be moved from set z to set p. ! restore a(npp1,j), set w(j)=0., and loop back to test dual ! coeffs again. a ( npp1 , j ) = asave w ( j ) = zero goto 150 end if end if ! ******  end of main loop  ****** ! come to here for termination. ! compute the norm of the final residual vector. 200 sm = zero if ( npp1 <= m ) then do i = npp1 , m sm = sm + b ( i ) ** 2 end do else do j = 1 , n w ( j ) = zero end do end if rnorm = sqrt ( sm ) return ! the following block of code is used as an internal subroutine ! to solve the triangular system, putting the solution in zz(). 300 do l = 1 , nsetp ip = nsetp + 1 - l if ( l /= 1 ) then do ii = 1 , ip zz ( ii ) = zz ( ii ) - a ( ii , jj ) * zz ( ip + 1 ) end do end if jj = index ( ip ) zz ( ip ) = zz ( ip ) / a ( ip , jj ) end do !   if ( rtnkey==1 ) then    !.....original !       !continue !   else if ( rtnkey/=2 ) then !       return !   end if if ( rtnkey /= 1 . and . rtnkey /= 2 ) return !......replaced with ! ******  secondary loop begins here ****** ! iteration counter. iter = iter + 1 if ( iter > itmax ) then mode = 3 !write (*,'(/a)') ' nnls quitting on iteration count.' goto 200 end if ! see if all new constrained coeffs are feasible. ! if not compute alpha. alpha = two do ip = 1 , nsetp l = index ( ip ) if ( zz ( ip ) <= zero ) then t = - x ( l ) / ( zz ( ip ) - x ( l )) if ( alpha > t ) then alpha = t jj = ip end if end if end do ! if all new constrained coeffs are feasible then alpha will ! still = 2.    if so exit from secondary loop to main loop. if ( alpha == two ) then ! ******  end of secondary loop  ****** do ip = 1 , nsetp i = index ( ip ) x ( i ) = zz ( ip ) end do ! all new coeffs are positive.  loop back to beginning. goto 100 else ! otherwise use alpha which will be between 0. and 1. to ! interpolate between the old x and the new zz. do ip = 1 , nsetp l = index ( ip ) x ( l ) = x ( l ) + alpha * ( zz ( ip ) - x ( l )) end do ! modify a and b and the index arrays to move coefficient i ! from set p to set z. i = index ( jj ) 350 x ( i ) = zero if ( jj /= nsetp ) then jj = jj + 1 do j = jj , nsetp ii = index ( j ) index ( j - 1 ) = ii call g1 ( a ( j - 1 , ii ), a ( j , ii ), cc , ss , a ( j - 1 , ii )) a ( j , ii ) = zero do l = 1 , n if ( l /= ii ) then ! apply procedure g2 (cc,ss,a(j-1,l),a(j,l)) temp = a ( j - 1 , l ) a ( j - 1 , l ) = cc * temp + ss * a ( j , l ) a ( j , l ) = - ss * temp + cc * a ( j , l ) end if end do ! apply procedure g2 (cc,ss,b(j-1),b(j)) temp = b ( j - 1 ) b ( j - 1 ) = cc * temp + ss * b ( j ) b ( j ) = - ss * temp + cc * b ( j ) end do end if npp1 = nsetp nsetp = nsetp - 1 iz1 = iz1 - 1 index ( iz1 ) = i ! see if the remaining coeffs in set p are feasible.  they should ! be because of the way alpha was determined. ! if any are infeasible it is due to round-off error.  any ! that are nonpositive will be set to zero ! and moved from set p to set z. do jj = 1 , nsetp i = index ( jj ) if ( x ( i ) <= zero ) goto 350 end do ! copy b( ) into zz( ).  then solve again and loop back. do i = 1 , m zz ( i ) = b ( i ) end do rtnkey = 2 goto 300 end if end subroutine nnls","tags":"","loc":"proc/nnls.html","title":"nnls – slsqp"},{"text":"private subroutine hfti(a, mda, m, n, b, mdb, nb, tau, krank, rnorm, h, g, ip) Rank-deficient least squares algorithm using\n  householder forward triangulation with column interchanges. References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a the array a initially contains the  m \\times n  matrix \\mathbf{A}\n of the least squares problem  \\mathbf{A} \\mathbf{x} = \\mathbf{b} .\n either m >= n or m < n is permitted.\n there is no restriction on the rank of a .\n the matrix a will be modified by the subroutine. integer, intent(in) :: mda the first dimensioning parameter of matrix a (mda >= m). integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(mdb,nb) :: b if nb = 0 the subroutine will make no reference\n to the array b . if nb > 0 the array b must\n initially contain the m x nb matrix b of the\n the least squares problem ax = b and on return\n the array b will contain the n x nb solution x . integer, intent(in) :: mdb first dimensioning parameter of matrix b (mdb>=max(m,n)) integer, intent(in) :: nb real(kind=wp), intent(in) :: tau absolute tolerance parameter for pseudorank\n determination, provided by the user. integer, intent(out) :: krank pseudorank of a , set by the subroutine. real(kind=wp), intent(out), dimension(nb) :: rnorm on exit, rnorm(j) will contain the euclidian\n norm of the residual vector for the problem\n defined by the j-th column vector of the array b . real(kind=wp), intent(inout), dimension(n) :: h array of working space real(kind=wp), intent(inout), dimension(n) :: g array of working space integer, intent(inout), dimension(n) :: ip integer array of working space\n recording permutation indices of column vectors Calls proc~~hfti~~CallsGraph proc~hfti hfti proc~diff diff proc~hfti->proc~diff proc~h12 h12 proc~hfti->proc~h12 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~hfti~~CalledByGraph proc~hfti hfti proc~lsei lsei proc~lsei->proc~hfti proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code hfti Source Code subroutine hfti ( a , mda , m , n , b , mdb , nb , tau , krank , rnorm , h , g , ip ) implicit none integer , intent ( in ) :: mda !! the first dimensioning parameter of matrix `a` (mda >= m). integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: mdb !! first dimensioning parameter of matrix `b` (mdb>=max(m,n)) integer , intent ( in ) :: nb real ( wp ), dimension ( mda , n ), intent ( inout ) :: a !! the array `a` initially contains the  m \\times n  matrix \\mathbf{A} !! of the least squares problem  \\mathbf{A} \\mathbf{x} = \\mathbf{b} . !! either `m >= n` or `m < n` is permitted. !! there is no restriction on the rank of `a`. !! the matrix `a` will be modified by the subroutine. real ( wp ), intent ( in ) :: tau !! absolute tolerance parameter for pseudorank !! determination, provided by the user. integer , intent ( out ) :: krank !! pseudorank of `a`, set by the subroutine. real ( wp ), dimension ( nb ), intent ( out ) :: rnorm !! on exit, `rnorm(j)` will contain the euclidian !! norm of the residual vector for the problem !! defined by the `j-th` column vector of the array `b`. real ( wp ), dimension ( n ), intent ( inout ) :: h !! array of working space real ( wp ), dimension ( n ), intent ( inout ) :: g !! array of working space integer , dimension ( n ), intent ( inout ) :: ip !! integer array of working space !! recording permutation indices of column vectors real ( wp ), dimension ( mdb , nb ), intent ( inout ) :: b !! if `nb = 0` the subroutine will make no reference !! to the array `b`. if `nb > 0` the array `b` must !! initially contain the `m x nb` matrix `b` of the !! the least squares problem `ax = b` and on return !! the array `b` will contain the `n x nb` solution `x`. integer :: i , ii , ip1 , j , jb , jj , k , kp1 , l , ldiag , lmax real ( wp ) :: hmax , sm , tmp logical :: need_lmax real ( wp ), parameter :: factor = 0.001_wp k = 0 ldiag = min ( m , n ) if ( ldiag <= 0 ) then ! the solution vectors, x, are now ! in the first  n  rows of the array b(,). krank = k return else do j = 1 , ldiag need_lmax = . true . if ( j /= 1 ) then ! update squared column lengths and find lmax lmax = j do l = j , n h ( l ) = h ( l ) - a ( j - 1 , l ) ** 2 if ( h ( l ) > h ( lmax ) ) lmax = l end do if ( diff ( hmax + factor * h ( lmax ), hmax ) > 0 ) need_lmax = . false . end if if ( need_lmax ) then ! compute squared column lengths and find lmax lmax = j do l = j , n h ( l ) = 0. do i = j , m h ( l ) = h ( l ) + a ( i , l ) ** 2 end do if ( h ( l ) > h ( lmax ) ) lmax = l end do hmax = h ( lmax ) end if ! lmax has been determined ! do column interchanges if needed. ip ( j ) = lmax if ( ip ( j ) /= j ) then do i = 1 , m tmp = a ( i , j ) a ( i , j ) = a ( i , lmax ) a ( i , lmax ) = tmp end do h ( lmax ) = h ( j ) end if ! compute the j-th transformation and apply it to a and b. call h12 ( 1 , j , j + 1 , m , a ( 1 , j ), 1 , h ( j ), a ( 1 , j + 1 ), 1 , mda , n - j ) call h12 ( 2 , j , j + 1 , m , a ( 1 , j ), 1 , h ( j ), b , 1 , mdb , nb ) end do ! determine the pseudorank, k, using the tolerance, tau. do j = 1 , ldiag if ( abs ( a ( j , j )) <= tau ) exit end do k = j - 1 kp1 = j end if ! compute the norms of the residual vectors. if ( nb > 0 ) then do jb = 1 , nb tmp = zero if ( kp1 <= m ) then do i = kp1 , m tmp = tmp + b ( i , jb ) ** 2 end do end if rnorm ( jb ) = sqrt ( tmp ) end do end if ! special for pseudorank = 0 if ( k > 0 ) then ! if the pseudorank is less than n compute householder ! decomposition of first k rows. if ( k /= n ) then do ii = 1 , k i = kp1 - ii call h12 ( 1 , i , kp1 , n , a ( i , 1 ), mda , g ( i ), a , mda , 1 , i - 1 ) end do end if if ( nb > 0 ) then do jb = 1 , nb ! solve the k by k triangular system. do l = 1 , k sm = zero i = kp1 - l if ( i /= k ) then ip1 = i + 1 do j = ip1 , k sm = sm + a ( i , j ) * b ( j , jb ) end do end if b ( i , jb ) = ( b ( i , jb ) - sm ) / a ( i , i ) end do ! complete computation of solution vector. if ( k /= n ) then do j = kp1 , n b ( j , jb ) = zero end do do i = 1 , k call h12 ( 2 , i , kp1 , n , a ( i , 1 ), mda , g ( i ), b ( 1 , jb ), 1 , mdb , 1 ) end do end if ! re-order the solution vector to compensate for the ! column interchanges. do jj = 1 , ldiag j = ldiag + 1 - jj if ( ip ( j ) /= j ) then l = ip ( j ) tmp = b ( l , jb ) b ( l , jb ) = b ( j , jb ) b ( j , jb ) = tmp end if end do end do end if else if ( nb > 0 ) then do jb = 1 , nb do i = 1 , n b ( i , jb ) = zero end do end do end if krank = k end subroutine hfti","tags":"","loc":"proc/hfti.html","title":"hfti – slsqp"},{"text":"private subroutine h12(mode, lpivot, l1, m, u, iue, up, c, ice, icv, ncv) Construction and/or application of a single\n  householder transformation  Q = I + u(u&#94;t)/b . References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode 1 or 2 -- selects algorithm h1 to construct and apply a\n householder transformation, or algorithm h2 to apply a\n previously constructed transformation. integer, intent(in) :: lpivot the index of the pivot element integer, intent(in) :: l1 if l1 <= m the transformation will be constructed to\n zero elements indexed from l1 through m .\n if l1 > m the subroutine does an identity transformation. integer, intent(in) :: m see li . real(kind=wp), intent(inout), dimension(iue,*) :: u on entry with mode = 1 , u contains the pivot\n vector. iue is the storage increment between elements.\n on exit when mode = 1 , u and up contain quantities\n defining the vector u of the householder transformation.\n on entry with mode = 2 , u and up should contain\n quantities previously computed with mode = 1 .  these will\n not be modified during the entry with mode = 2 . dimension[u(iue,m)] integer, intent(in) :: iue see u . real(kind=wp), intent(inout) :: up see u . real(kind=wp), intent(inout), dimension(*) :: c on entry with mode = 1 or 2 , c contains a matrix which\n will be regarded as a set of vectors to which the\n householder transformation is to be applied.\n on exit c contains the set of transformed vectors. integer, intent(in) :: ice storage increment between elements of vectors in c . integer, intent(in) :: icv storage increment between vectors in c . integer, intent(in) :: ncv number of vectors in c to be transformed. if ncv <= 0 no operations will be done on c . Called By proc~~h12~~CalledByGraph proc~h12 h12 proc~lsi lsi proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~hfti hfti proc~hfti->proc~h12 proc~lsei lsei proc~lsei->proc~h12 proc~lsei->proc~lsi proc~lsei->proc~hfti proc~nnls nnls proc~nnls->proc~h12 proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp proc~ldp->proc~nnls var panproch12CalledByGraph = svgPanZoom('#proch12CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code h12 Source Code subroutine h12 ( mode , lpivot , l1 , m , u , iue , up , c , ice , icv , ncv ) implicit none integer , intent ( in ) :: mode !! `1` or `2` -- selects algorithm ***h1*** to construct and apply a !! householder transformation, or algorithm ***h2*** to apply a !! previously constructed transformation. integer , intent ( in ) :: lpivot !! the index of the pivot element integer , intent ( in ) :: l1 !! if `l1 <= m` the transformation will be constructed to !! zero elements indexed from `l1` through `m`. !! if `l1 > m` the subroutine does an identity transformation. integer , intent ( in ) :: m !! see `li`. integer , intent ( in ) :: iue !! see `u`. real ( wp ), dimension ( iue , * ), intent ( inout ) :: u !! on entry with `mode = 1`, `u` contains the pivot !! vector.  `iue` is the storage increment between elements. !! on exit when `mode = 1`, `u` and `up` contain quantities !! defining the vector `u` of the householder transformation. !! on entry with `mode = 2`, `u` and `up` should contain !! quantities previously computed with `mode = 1`.  these will !! not be modified during the entry with `mode = 2`. !! `dimension[u(iue,m)]` real ( wp ), intent ( inout ) :: up !! see `u`. real ( wp ), dimension ( * ), intent ( inout ) :: c !! on entry with `mode = 1 or 2`, `c` contains a matrix which !! will be regarded as a set of vectors to which the !! householder transformation is to be applied. !! on exit `c` contains the set of transformed vectors. integer , intent ( in ) :: ice !! storage increment between elements of vectors in `c`. integer , intent ( in ) :: icv !! storage increment between vectors in `c`. integer , intent ( in ) :: ncv !! number of vectors in `c` to be transformed. if `ncv <= 0` !! no operations will be done on `c`. integer :: i , i2 , i3 , i4 , incr , j real ( wp ) :: b , cl , clinv , sm if ( 0 >= lpivot . or . lpivot >= l1 . or . l1 > m ) return cl = abs ( u ( 1 , lpivot )) if ( mode /= 2 ) then ! construct the transformation. do j = l1 , m cl = max ( abs ( u ( 1 , j )), cl ) end do if ( cl <= 0 ) return clinv = one / cl sm = ( u ( 1 , lpivot ) * clinv ) ** 2 do j = l1 , m sm = sm + ( u ( 1 , j ) * clinv ) ** 2 end do cl = cl * sqrt ( sm ) if ( u ( 1 , lpivot ) > 0 ) cl = - cl up = u ( 1 , lpivot ) - cl u ( 1 , lpivot ) = cl else if ( cl <= 0 ) then return end if if ( ncv > 0 ) then ! apply the transformation i+u*(u**t)/b to c. b = up * u ( 1 , lpivot ) ! b must be nonpositive here. if ( b < 0 ) then b = one / b i2 = 1 - icv + ice * ( lpivot - 1 ) incr = ice * ( l1 - lpivot ) do j = 1 , ncv i2 = i2 + icv i3 = i2 + incr i4 = i3 sm = c ( i2 ) * up do i = l1 , m sm = sm + c ( i3 ) * u ( 1 , i ) i3 = i3 + ice end do if ( sm /= 0 ) then sm = sm * b c ( i2 ) = c ( i2 ) + sm * up do i = l1 , m c ( i4 ) = c ( i4 ) + sm * u ( 1 , i ) i4 = i4 + ice end do end if end do end if end if end subroutine h12","tags":"","loc":"proc/h12.html","title":"h12 – slsqp"},{"text":"private subroutine g1(a, b, c, s, sig) Compute orthogonal rotation matrix. Compute matrix  \\left[ \\begin{array}{cc} c & s \\\\ -s & c \\end{array} \\right] \n  so that \n  \\left[ \\begin{array}{cc} c & s \\\\ -s & c \\end{array} \\right]\n  \\left[ \\begin{array}{c} a \\\\ b \\end{array} \\right]  =\n  \\left[ \\begin{array}{c} \\sqrt{a&#94;2+b&#94;2} \\\\ 0 \\end{array} \\right]\n   Compute  \\sigma = \\sqrt{a&#94;2+b&#94;2}   \\sigma  is computed last to allow for the possibility that sig may be in the same location as a or b . References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s real(kind=wp) :: sig Called By proc~~g1~~CalledByGraph proc~g1 g1 proc~nnls nnls proc~nnls->proc~g1 proc~ldp ldp proc~ldp->proc~nnls proc~lsi lsi proc~lsi->proc~ldp proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp var panprocg1CalledByGraph = svgPanZoom('#procg1CalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code g1 Source Code subroutine g1 ( a , b , c , s , sig ) implicit none real ( wp ) :: a real ( wp ) :: b real ( wp ) :: sig real ( wp ), intent ( out ) :: c real ( wp ), intent ( out ) :: s real ( wp ) :: xr , yr if ( abs ( a ) > abs ( b ) ) then xr = b / a yr = sqrt ( one + xr ** 2 ) c = sign ( one / yr , a ) s = c * xr sig = abs ( a ) * yr else if ( b /= zero ) then xr = a / b yr = sqrt ( one + xr ** 2 ) s = sign ( one / yr , b ) c = s * xr sig = abs ( b ) * yr else sig = zero c = zero s = one end if end if end subroutine g1","tags":"","loc":"proc/g1.html","title":"g1 – slsqp"},{"text":"private subroutine ldl(n, a, z, sigma, w) LDL&#94;T - rank-one - update Purpose: Updates the LDL&#94;T factors of matrix A\n  by rank-one matrix \\sigma z z&#94;T . Reference R. Fletcher, M.J.D. Powell,\n    \" On the modification of LDL' factorization \".\n    Mathematics of Computation Vol. 28, No. 128, p. 1067-1087, October 1974. History D. Kraft, DFVLR - institut fuer dynamik der flugsysteme\n    d-8031  oberpfaffenhofen Status: 15. january 1980 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the coefficient matrix a real(kind=wp), intent(inout), dimension(*) :: a In: positive definite matrix of dimension n ;\n only the lower triangle is used and is stored column by\n column as one dimensional array of dimension n*(n+1)/2 . Out: updated LDL&#94;T factors real(kind=wp), intent(inout), dimension(*) :: z vector of dimension n of updating elements. real(kind=wp), intent(in) :: sigma scalar factor by which the modifying dyade z z&#94;T is multiplied. real(kind=wp), intent(inout), dimension(*) :: w working array of dimension n (used only if  \\sigma \\lt 0  ). Called By proc~~ldl~~CalledByGraph proc~ldl ldl proc~slsqpb slsqpb proc~slsqpb->proc~ldl proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ldl Source Code subroutine ldl ( n , a , z , sigma , w ) implicit none integer , intent ( in ) :: n !! order of the coefficient matrix `a` real ( wp ), intent ( in ) :: sigma !! scalar factor by which the modifying dyade z z&#94;T is multiplied. real ( wp ), dimension ( * ), intent ( inout ) :: a !! ***In:*** positive definite matrix of dimension `n`; !! only the lower triangle is used and is stored column by !! column as one dimensional array of dimension `n*(n+1)/2`. !! !! ***Out:*** updated LDL&#94;T factors real ( wp ), dimension ( * ), intent ( inout ) :: w !! working array of dimension `n` (used only if  \\sigma \\lt 0  ). real ( wp ), dimension ( * ), intent ( inout ) :: z !! vector of dimension `n` of updating elements. integer :: i , ij , j real ( wp ) :: t , v , u , tp , beta , alpha , delta , gamma if ( sigma /= zero ) then ij = 1 t = one / sigma if ( sigma <= zero ) then ! prepare negative update do i = 1 , n w ( i ) = z ( i ) end do do i = 1 , n v = w ( i ) t = t + v * v / a ( ij ) do j = i + 1 , n ij = ij + 1 w ( j ) = w ( j ) - v * a ( ij ) end do ij = ij + 1 end do if ( t >= zero ) t = epmach / sigma do i = 1 , n j = n + 1 - i ij = ij - i u = w ( j ) w ( j ) = t t = t - u * u / a ( ij ) end do end if ! here updating begins do i = 1 , n v = z ( i ) delta = v / a ( ij ) if ( sigma < zero ) tp = w ( i ) if ( sigma > zero ) tp = t + delta * v alpha = tp / t a ( ij ) = alpha * a ( ij ) if ( i == n ) return beta = delta / tp if ( alpha > four ) then gamma = t / tp do j = i + 1 , n ij = ij + 1 u = a ( ij ) a ( ij ) = gamma * u + beta * z ( j ) z ( j ) = z ( j ) - v * u end do else do j = i + 1 , n ij = ij + 1 z ( j ) = z ( j ) - v * a ( ij ) a ( ij ) = a ( ij ) + beta * z ( j ) end do end if ij = ij + 1 t = tp end do end if end subroutine ldl","tags":"","loc":"proc/ldl.html","title":"ldl – slsqp"},{"text":"private subroutine enforce_bounds(x, xl, xu) enforce the bound constraints on x. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x optimization variable vector real(kind=wp), intent(in), dimension(:) :: xl lower bounds (must be same dimension as x ) real(kind=wp), intent(in), dimension(:) :: xu upper bounds (must be same dimension as x ) Called By proc~~enforce_bounds~~CalledByGraph proc~enforce_bounds enforce_bounds proc~slsqpb slsqpb proc~slsqpb->proc~enforce_bounds proc~lsq lsq proc~slsqpb->proc~lsq proc~lsq->proc~enforce_bounds proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code enforce_bounds Source Code subroutine enforce_bounds ( x , xl , xu ) implicit none real ( wp ), dimension (:), intent ( inout ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( in ) :: xl !! lower bounds (must be same dimension as `x`) real ( wp ), dimension (:), intent ( in ) :: xu !! upper bounds (must be same dimension as `x`) where ( x < xl ) x = xl elsewhere ( x > xu ) x = xu end where end subroutine enforce_bounds","tags":"","loc":"proc/enforce_bounds.html","title":"enforce_bounds – slsqp"},{"text":"private subroutine destroy_slsqpb_data(me) Destructor for slsqpb_data type. Arguments Type Intent Optional Attributes Name class( slsqpb_data ), intent(out) :: me Source Code destroy_slsqpb_data Source Code subroutine destroy_slsqpb_data ( me ) implicit none class ( slsqpb_data ), intent ( out ) :: me end subroutine destroy_slsqpb_data","tags":"","loc":"proc/destroy_slsqpb_data.html","title":"destroy_slsqpb_data – slsqp"},{"text":"private subroutine destroy_linmin_data(me) Destructor for linmin_data type. Arguments Type Intent Optional Attributes Name class( linmin_data ), intent(out) :: me Source Code destroy_linmin_data Source Code subroutine destroy_linmin_data ( me ) implicit none class ( linmin_data ), intent ( out ) :: me end subroutine destroy_linmin_data","tags":"","loc":"proc/destroy_linmin_data.html","title":"destroy_linmin_data – slsqp"},{"text":"subroutine test_func(me, x, f, c) Compute the objective function and constraints Minimize:  f = x_1&#94;2 + x_2&#94;2 + x_3  Subject to:  c_1 = x_1 x_2 - x_3 = 0   c_2 = x_3 - 1 \\ge 0  Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out) :: f value of the objective function real(kind=wp), intent(out), dimension(:) :: c the constraint vector dimension(m) ,\n equality constraints (if any) first. Source Code test_func Source Code subroutine test_func ( me , x , f , c ) !!  Compute the objective function and constraints !! !!  Minimize: !! !!   *  f = x_1&#94;2 + x_2&#94;2 + x_3  !! !!  Subject to: !! !!   *  c_1 = x_1 x_2 - x_3 = 0  !!   *  c_2 = x_3 - 1 \\ge 0  implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( out ) :: f !! value of the objective function real ( wp ), dimension (:), intent ( out ) :: c !! the constraint vector `dimension(m)`, !! equality constraints (if any) first. f = x ( 1 ) ** 2 + x ( 2 ) ** 2 + x ( 3 ) !objective function c ( 1 ) = x ( 1 ) * x ( 2 ) - x ( 3 ) !equality constraint (==0) c ( 2 ) = x ( 3 ) - 1.0_wp !inequality constraint (>=0) end subroutine test_func","tags":"","loc":"proc/test_func.html","title":"test_func – slsqp"},{"text":"subroutine test_grad(me, x, g, a) compute the gradients. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out), dimension(:) :: g objective function partials w.r.t x dimension(n) real(kind=wp), intent(out), dimension(:,:) :: a gradient matrix of constraints w.r.t. x dimension(m,n) Source Code test_grad Source Code subroutine test_grad ( me , x , g , a ) !! compute the gradients. implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( out ) :: g !! objective function partials w.r.t x `dimension(n)` real ( wp ), dimension (:,:), intent ( out ) :: a !! gradient matrix of constraints w.r.t. x `dimension(m,n)` g ( 1 ) = 2.0_wp * x ( 1 ) g ( 2 ) = 2.0_wp * x ( 2 ) g ( 3 ) = 1.0_wp a ( 1 , 1 ) = x ( 2 ) a ( 1 , 2 ) = x ( 1 ) a ( 1 , 3 ) = - 1.0_wp a ( 2 , 1 ) = 0.0_wp a ( 2 , 2 ) = 0.0_wp a ( 2 , 3 ) = 1.0_wp end subroutine test_grad","tags":"","loc":"proc/test_grad.html","title":"test_grad – slsqp"},{"text":"subroutine report_iteration(me, iter, x, f, c) Uses: iso_fortran_env proc~~report_iteration~~UsesGraph proc~report_iteration report_iteration iso_fortran_env iso_fortran_env iso_fortran_env->proc~report_iteration Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. report an iteration (print to the console). Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: iter real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in) :: f real(kind=wp), intent(in), dimension(:) :: c Source Code report_iteration Source Code subroutine report_iteration ( me , iter , x , f , c ) !! report an iteration (print to the console). use , intrinsic :: iso_fortran_env , only : output_unit implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: iter real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), intent ( in ) :: f real ( wp ), dimension (:), intent ( in ) :: c !write a header: if ( iter == 0 ) then write ( output_unit , '(*(A20,1X))' ) 'iteration' , & 'x(1)' , 'x(2)' , 'x(3)' , & 'f(1)' , 'c(1)' , 'c(2)' end if !write the iteration data: write ( output_unit , '(I20,1X,(*(F20.16,1X)))' ) iter , x , f , c end subroutine report_iteration","tags":"","loc":"proc/report_iteration.html","title":"report_iteration – slsqp"},{"text":"subroutine rosenbrock_func(me, x, f, c) Rosenbrock function Minimize the Rosenbrock function:  f(x) = 100 (x_2 - x_1)&#94;2 + (1 - x_1)&#94;2 ,\n subject to the inequality constraint:  x_1&#94;2 + x_2&#94;2 \\le 1 . see: http://www.mathworks.com/help/optim/ug/example-nonlinear-constrained-minimization.html Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out) :: f value of the objective function real(kind=wp), intent(out), dimension(:) :: c the constraint vector dimension(m) ,\n equality constraints (if any) first. Source Code rosenbrock_func Source Code subroutine rosenbrock_func ( me , x , f , c ) !! Rosenbrock function !! !! Minimize the Rosenbrock function:  f(x) = 100 (x_2 - x_1)&#94;2 + (1 - x_1)&#94;2 , !! subject to the inequality constraint:  x_1&#94;2 + x_2&#94;2 \\le 1 . !! !! see: http://www.mathworks.com/help/optim/ug/example-nonlinear-constrained-minimization.html implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( out ) :: f !! value of the objective function real ( wp ), dimension (:), intent ( out ) :: c !! the constraint vector `dimension(m)`, !! equality constraints (if any) first. f = 10 0.0_wp * ( x ( 2 ) - x ( 1 ) ** 2 ) ** 2 + ( 1.0_wp - x ( 1 )) ** 2 !objective function c ( 1 ) = 1.0_wp - x ( 1 ) ** 2 - x ( 2 ) ** 2 !equality constraint (>=0) end subroutine rosenbrock_func","tags":"","loc":"proc/rosenbrock_func.html","title":"rosenbrock_func – slsqp"},{"text":"subroutine rosenbrock_grad(me, x, g, a) gradients for rosenbrock_func . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out), dimension(:) :: g objective function partials w.r.t x dimension(n) real(kind=wp), intent(out), dimension(:,:) :: a gradient matrix of constraints w.r.t. x dimension(m,n) Source Code rosenbrock_grad Source Code subroutine rosenbrock_grad ( me , x , g , a ) !! gradients for [[rosenbrock_func]]. implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( out ) :: g !! objective function partials w.r.t x `dimension(n)` real ( wp ), dimension (:,:), intent ( out ) :: a !! gradient matrix of constraints w.r.t. x `dimension(m,n)` g ( 1 ) = - 40 0.0_wp * ( x ( 2 ) - x ( 1 ) ** 2 ) * x ( 1 ) - 2.0_wp * ( 1.0_wp - x ( 1 )) !df/x1 g ( 2 ) = 20 0.0_wp * ( x ( 2 ) - x ( 1 ) ** 2 ) !df/x2 a ( 1 , 1 ) = - 2.0_wp * x ( 1 ) ! dc/dx1 a ( 1 , 2 ) = - 2.0_wp * x ( 2 ) ! dc/dx2 end subroutine rosenbrock_grad","tags":"","loc":"proc/rosenbrock_grad.html","title":"rosenbrock_grad – slsqp"},{"text":"subroutine report_iteration(me, iter, x, f, c) Uses: iso_fortran_env proc~~report_iteration~2~~UsesGraph proc~report_iteration~2 report_iteration iso_fortran_env iso_fortran_env iso_fortran_env->proc~report_iteration~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. report an iteration (print to the console). Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: iter real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in) :: f real(kind=wp), intent(in), dimension(:) :: c Source Code report_iteration Source Code subroutine report_iteration ( me , iter , x , f , c ) use , intrinsic :: iso_fortran_env , only : output_unit !! report an iteration (print to the console). implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: iter real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), intent ( in ) :: f real ( wp ), dimension (:), intent ( in ) :: c !write a header: if ( iter == 0 ) then write ( output_unit , '(*(A20,1X))' ) 'iteration' , 'x(1)' , 'x(2)' , 'f(1)' , 'c(1)' end if !write the iteration data: write ( output_unit , '(I20,1X,(*(F20.16,1X)))' ) iter , x , f , c end subroutine report_iteration","tags":"","loc":"proc/report_iteration~2.html","title":"report_iteration – slsqp"},{"text":"Uses: iso_fortran_env module~~slsqp_kinds~~UsesGraph module~slsqp_kinds slsqp_kinds iso_fortran_env iso_fortran_env iso_fortran_env->module~slsqp_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Numeric kind definitions. Used By module~~slsqp_kinds~~UsedByGraph module~slsqp_kinds slsqp_kinds module~slsqp_support slsqp_support module~slsqp_kinds->module~slsqp_support program~slsqp_test slsqp_test module~slsqp_kinds->program~slsqp_test program~slsqp_test_2 slsqp_test_2 module~slsqp_kinds->program~slsqp_test_2 module~slsqp_core slsqp_core module~slsqp_kinds->module~slsqp_core module~slsqp_module slsqp_module module~slsqp_kinds->module~slsqp_module module~slsqp_support->module~slsqp_core module~slsqp_support->module~slsqp_module module~slsqp_core->module~slsqp_module module~slsqp_module->program~slsqp_test module~slsqp_module->program~slsqp_test_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables wp Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 Using \"double precision\" real kinds","tags":"","loc":"module/slsqp_kinds.html","title":"slsqp_kinds – slsqp"},{"text":"Uses: slsqp_kinds module~~slsqp_support~~UsesGraph module~slsqp_support slsqp_support module~slsqp_kinds slsqp_kinds module~slsqp_kinds->module~slsqp_support iso_fortran_env iso_fortran_env iso_fortran_env->module~slsqp_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Support routines for SLSQP. For example, routines from BLAS and LINPACK .\n  These have also been refactored into modern Fortran. Used By module~~slsqp_support~~UsedByGraph module~slsqp_support slsqp_support module~slsqp_module slsqp_module module~slsqp_support->module~slsqp_module module~slsqp_core slsqp_core module~slsqp_support->module~slsqp_core program~slsqp_test_2 slsqp_test_2 module~slsqp_module->program~slsqp_test_2 program~slsqp_test slsqp_test module~slsqp_module->program~slsqp_test module~slsqp_core->module~slsqp_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables epmach zero one two four ten hun Functions ddot dnrm2 Subroutines daxpy dcopy dscal Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: epmach = epsilon(1.0_wp) real(kind=wp), public, parameter :: zero = 0.0_wp real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public, parameter :: two = 2.0_wp real(kind=wp), public, parameter :: four = 4.0_wp real(kind=wp), public, parameter :: ten = 10.0_wp real(kind=wp), public, parameter :: hun = 100.0_wp Functions public function ddot (n, dx, incx, dy, incy) forms the dot product of two vectors.\n  uses unrolled loops for increments equal to one. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy Return Value real(kind=wp) public function dnrm2 (n, x, incx) Function that returns the Euclidean norm\n   \\sqrt{ \\mathbf{x}&#94;T \\mathbf{x} }  of a vector  \\mathbf{x} . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(*) :: x integer, intent(in) :: incx Return Value real(kind=wp) Subroutines public subroutine daxpy (n, da, dx, incx, dy, incy) constant times a vector plus a vector.\n  uses unrolled loops for increments equal to one. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: da real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy public subroutine dcopy (n, dx, incx, dy, incy) copies a vector, x, to a vector, y.\n  uses unrolled loops for increments equal to one. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: dx (*) integer :: incx real(kind=wp) :: dy (*) integer :: incy public subroutine dscal (n, da, dx, incx) scales a vector by a constant.\n  uses unrolled loops for increment equal to one. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: da real(kind=wp) :: dx (*) integer :: incx","tags":"","loc":"module/slsqp_support.html","title":"slsqp_support – slsqp"},{"text":"Uses: slsqp_kinds slsqp_support slsqp_core iso_fortran_env module~~slsqp_module~~UsesGraph module~slsqp_module slsqp_module module~slsqp_support slsqp_support module~slsqp_support->module~slsqp_module module~slsqp_core slsqp_core module~slsqp_support->module~slsqp_core iso_fortran_env iso_fortran_env iso_fortran_env->module~slsqp_module module~slsqp_kinds slsqp_kinds iso_fortran_env->module~slsqp_kinds module~slsqp_kinds->module~slsqp_module module~slsqp_kinds->module~slsqp_support module~slsqp_kinds->module~slsqp_core module~slsqp_core->module~slsqp_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Module containing the object-oriented interface to the SLSQP method.\n  It is called using the slsqp_solver class, which\n  is the only public entity in this module. Used By module~~slsqp_module~~UsedByGraph module~slsqp_module slsqp_module program~slsqp_test_2 slsqp_test_2 module~slsqp_module->program~slsqp_test_2 program~slsqp_test slsqp_test module~slsqp_module->program~slsqp_test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces func grad iterfunc Derived Types slsqp_solver Functions mode_to_status_message Subroutines stop_iterations initialize_slsqp destroy_slsqp slsqp_wrapper report_message Abstract Interfaces abstract interface private subroutine func (me, x, f, c) for computing the function Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out) :: f value of the objective function real(kind=wp), intent(out), dimension(:) :: c the constraint vector dimension(m) ,\n equality constraints (if any) first. abstract interface private subroutine grad (me, x, g, a) for computing the gradients Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out), dimension(:) :: g objective function partials w.r.t x dimension(n) real(kind=wp), intent(out), dimension(:,:) :: a gradient matrix of constraints w.r.t. x dimension(m,n) abstract interface private subroutine iterfunc (me, iter, x, f, c) for reporting an iteration Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: iter iteration number real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(in) :: f value of the objective function real(kind=wp), intent(in), dimension(:) :: c the constraint vector dimension(m) ,\n equality constraints (if any) first. Derived Types type, public :: slsqp_solver The main class used to interface with the SLSQP solver. Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of optimization variables ( n > 0 ) integer, private :: m = 0 number of constraints ( m \\ge 0 ) integer, private :: meq = 0 number of equality constraints ( m \\ge m_{eq} \\ge 0 ) integer, private :: max_iter = 0 maximum number of iterations real(kind=wp), private :: acc = zero accuracy tolerance real(kind=wp), private :: alphamin = 0.1_wp min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real(kind=wp), private :: alphamax = 1.0_wp max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  integer, private :: iprint = output_unit unit number of status printing (0 for no printing) real(kind=wp), private, dimension(:), allocatable :: xl lower bound on x real(kind=wp), private, dimension(:), allocatable :: xu upper bound on x integer, private :: l_w = 0 size of w real(kind=wp), private, dimension(:), allocatable :: w real work array integer, private :: l_jw = 0 size of jw integer, private, dimension(:), allocatable :: jw integer work array procedure( func ), private, pointer :: f => null() problem function subroutine procedure( grad ), private, pointer :: g => null() gradient subroutine procedure( iterfunc ), private, pointer :: report => null() for reporting an iteration integer, private :: linesearch_mode = 1 linesearch mode: type( linmin_data ), private :: linmin data formerly within linmin .\n Only used when linesearch_mode=2 type( slsqpb_data ), private :: slsqpb data formerly within slsqpb . logical, private :: user_triggered_stop = .false. if the abort method has been called\n to stop the iterations Type-Bound Procedures procedure, public :: initialize => initialize_slsqp procedure, public :: destroy => destroy_slsqp procedure, public :: optimize => slsqp_wrapper procedure, public :: abort => stop_iterations procedure, private :: report_message for reporting messages to the user Functions private pure function mode_to_status_message (imode) result(message) Convert the slsqp mode flag to a message string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: imode Return Value character(len=:),\n  allocatable Subroutines private subroutine stop_iterations (me) A method that the user can call to stop the iterations.\n  (it can be called in any of the functions).\n  SLSQP will stop at the end of the next iteration. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me private subroutine initialize_slsqp (me, n, m, meq, max_iter, acc, f, g, xl, xu, status_ok, linesearch_mode, iprint, report, alphamin, alphamax) initialize the slsqp_solver class.  see slsqp for more details. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: n the number of varibles,  n \\ge 1  integer, intent(in) :: m total number of constraints,  m \\ge 0  integer, intent(in) :: meq number of equality constraints,  m_{eq} \\ge 0  integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: acc accuracy procedure( func ) :: f problem function procedure( grad ) :: g function to compute gradients real(kind=wp), intent(in), dimension(n) :: xl lower bounds on x real(kind=wp), intent(in), dimension(n) :: xu upper bounds on x logical, intent(out) :: status_ok will be false if there were errors integer, intent(in), optional :: linesearch_mode 1 = inexact (default), 2 = exact integer, intent(in), optional :: iprint unit number of status messages (default=output_unit) procedure( iterfunc ), optional :: report user-defined procedure that will be called once per iteration real(kind=wp), intent(in), optional :: alphamin minimum alpha for linesearch [default 0.1] real(kind=wp), intent(in), optional :: alphamax maximum alpha for linesearch [default 1.0] private subroutine destroy_slsqp (me) destructor for slsqp_solver . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(out) :: me private subroutine slsqp_wrapper (me, x, istat, iterations, status_message) main routine for calling slsqp . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x in: initial optimization variables, out: solution. integer, intent(out) :: istat status code (see mode in slsqp ). integer, intent(out), optional :: iterations number of iterations character(len=:), intent(out), optional allocatable :: status_message string status message corresponding to istat private subroutine report_message (me, str, ival, rval, fatal) Report a message from an slsqp_solver class. This uses the iprint variable in the class as the unit number for printing. Note: for fatal errors,\n  if no unit is specified, the error_unit is used. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(in) :: me character(len=*), intent(in) :: str the message to report. integer, intent(in), optional :: ival optional integer to print after the message. real(kind=wp), intent(in), optional :: rval optional real to print after the message. logical, intent(in), optional :: fatal if True, then the program is stopped (default=False).","tags":"","loc":"module/slsqp_module.html","title":"slsqp_module – slsqp"},{"text":"Uses: slsqp_kinds slsqp_support module~~slsqp_core~~UsesGraph module~slsqp_core slsqp_core module~slsqp_support slsqp_support module~slsqp_support->module~slsqp_core module~slsqp_kinds slsqp_kinds module~slsqp_kinds->module~slsqp_core module~slsqp_kinds->module~slsqp_support iso_fortran_env iso_fortran_env iso_fortran_env->module~slsqp_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Core subroutines for the SLSQP optimization method.\n  These are refactoried versions of the original routines. Used By module~~slsqp_core~~UsedByGraph module~slsqp_core slsqp_core module~slsqp_module slsqp_module module~slsqp_core->module~slsqp_module program~slsqp_test_2 slsqp_test_2 module~slsqp_module->program~slsqp_test_2 program~slsqp_test slsqp_test module~slsqp_module->program~slsqp_test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types linmin_data slsqpb_data Functions diff linmin Subroutines slsqp slsqpb lsq lsei lsi ldp nnls hfti h12 g1 ldl enforce_bounds destroy_slsqpb_data destroy_linmin_data Derived Types type, public :: linmin_data data formerly saved in linmin routine. Components Type Visibility Attributes Name Initial real(kind=wp), public :: a = zero real(kind=wp), public :: b = zero real(kind=wp), public :: d = zero real(kind=wp), public :: e = zero real(kind=wp), public :: p = zero real(kind=wp), public :: q = zero real(kind=wp), public :: r = zero real(kind=wp), public :: u = zero real(kind=wp), public :: v = zero real(kind=wp), public :: w = zero real(kind=wp), public :: x = zero real(kind=wp), public :: m = zero real(kind=wp), public :: fu = zero real(kind=wp), public :: fv = zero real(kind=wp), public :: fw = zero real(kind=wp), public :: fx = zero real(kind=wp), public :: tol1 = zero real(kind=wp), public :: tol2 = zero Type-Bound Procedures procedure, public :: destroy => destroy_linmin_data type, public :: slsqpb_data data formerly saved in slsqpb . Components Type Visibility Attributes Name Initial real(kind=wp), public :: t = zero real(kind=wp), public :: f0 = zero real(kind=wp), public :: h1 = zero real(kind=wp), public :: h2 = zero real(kind=wp), public :: h3 = zero real(kind=wp), public :: h4 = zero real(kind=wp), public :: t0 = zero real(kind=wp), public :: gs = zero real(kind=wp), public :: tol = zero real(kind=wp), public :: alpha = zero integer, public :: line = 0 integer, public :: iexact = 0 integer, public :: incons = 0 integer, public :: ireset = 0 integer, public :: itermx = 0 integer, public :: n1 = 0 integer, public :: n2 = 0 integer, public :: n3 = 0 Type-Bound Procedures procedure, public :: destroy => destroy_slsqpb_data Functions private pure elemental function diff (u, v) result(d) Replaced statement function in the original code.\n  Returns  d = u - v . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: u real(kind=wp), intent(in) :: v Return Value real(kind=wp) private function linmin (mode, ax, bx, f, tol, a, b, d, e, p, q, r, u, v, w, x, m, fu, fv, fw, fx, tol1, tol2) Linesearch without derivatives (used by slsqp if linesearch_mode=2 ).\n  Returns the abscissa approximating the point where f attains a minimum. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: mode controls reverse communication\n must be set to 0 initially, returns with intermediate\n values 1 and 2 which must not be changed by the user,\n ends with convergence with value 3. real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp) :: f function value at linmin which is to be brought in by\n reverse communication controlled by mode real(kind=wp), intent(in) :: tol desired length of interval of uncertainty of final result real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(inout) :: d real(kind=wp), intent(inout) :: e real(kind=wp), intent(inout) :: p real(kind=wp), intent(inout) :: q real(kind=wp), intent(inout) :: r real(kind=wp), intent(inout) :: u real(kind=wp), intent(inout) :: v real(kind=wp), intent(inout) :: w real(kind=wp), intent(inout) :: x real(kind=wp), intent(inout) :: m real(kind=wp), intent(inout) :: fu real(kind=wp), intent(inout) :: fv real(kind=wp), intent(inout) :: fw real(kind=wp), intent(inout) :: fx real(kind=wp), intent(inout) :: tol1 real(kind=wp), intent(inout) :: tol2 Return Value real(kind=wp) Subroutines public subroutine slsqp (m, meq, la, n, x, xl, xu, f, c, g, a, acc, iter, mode, w, l_w, jw, l_jw, sdat, ldat, alphamin, alphamax) slsqp : s equential l east sq uares p rogramming\n  to solve general nonlinear optimization problems Arguments Type Intent Optional Attributes Name integer, intent(in) :: m is the total number of constraints,  m \\ge 0  integer, intent(in) :: meq is the number of equality constraints,  m_{eq} \\ge 0  integer, intent(in) :: la see a ,  la \\ge \\max(m,1)  integer, intent(in) :: n is the number of variables,  n \\ge 1  real(kind=wp), intent(inout), dimension(n) :: x x() stores the current iterate of the n vector x on entry x() must be initialized. on exit x() stores the solution vector x if mode = 0 . real(kind=wp), intent(in), dimension(n) :: xl xl() stores an n vector of lower bounds xl to x . real(kind=wp), intent(in), dimension(n) :: xu xu() stores an n vector of upper bounds xu to x . real(kind=wp), intent(in) :: f is the value of the objective function. real(kind=wp), intent(in), dimension(la) :: c c() stores the m vector c of constraints,\n equality constraints (if any) first.\n dimension of c must be greater or equal la ,\n which must be greater or equal max(1,m) . real(kind=wp), intent(in), dimension(n+1) :: g g() stores the n vector g of partials of the\n objective function; dimension of g must be\n greater or equal n+1 . real(kind=wp), intent(in), dimension(la,n+1) :: a the la by n + 1 array a() stores\n the m by n matrix a of constraint normals. a() has first dimensioning parameter la ,\n which must be greater or equal max(1,m) . real(kind=wp), intent(inout) :: acc abs(acc) controls the final accuracy.\n if acc < zero an exact linesearch is performed,\n otherwise an armijo-type linesearch is used. integer, intent(inout) :: iter prescribes the maximum number of iterations.\n on exit iter indicates the number of iterations. integer, intent(inout) :: mode mode controls calculation: real(kind=wp), intent(inout), dimension(l_w) :: w w() is a one dimensional working space.\n the first m+n+n*n1/2 elements of w must not be\n changed between subsequent calls of slsqp .\n on return w(1) ... w(m) contain the multipliers\n associated with the general constraints, while w(m+1) ... w(m+n(n+1)/2) store the cholesky factor l*d*l(t) of the approximate hessian of the\n lagrangian columnwise dense as lower triangular\n unit matrix l with d in its 'diagonal' and w(m+n(n+1)/2+n+2 ... w(m+n(n+1)/2+n+2+m+2n) contain the multipliers associated with all\n constraints of the quadratic program finding\n the search direction to the solution x* integer, intent(in) :: l_w the length of w , which should be at least: integer, intent(inout), dimension(l_jw) :: jw jw() is a one dimensional integer working space integer, intent(in) :: l_jw the length of jw which should be at least mineq = m - meq + 2*(n+1) . type( slsqpb_data ), intent(inout) :: sdat data for slsqpb . type( linmin_data ), intent(inout) :: ldat data for linmin . real(kind=wp), intent(in) :: alphamin min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real(kind=wp), intent(in) :: alphamax max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  private subroutine slsqpb (m, meq, la, n, x, xl, xu, f, c, g, a, acc, iter, mode, r, l, x0, mu, s, u, v, w, iw, t, f0, h1, h2, h3, h4, n1, n2, n3, t0, gs, tol, line, alpha, iexact, incons, ireset, itermx, ldat, alphamin, alphamax) nonlinear programming by solving sequentially quadratic programs Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: meq integer, intent(in) :: la integer, intent(in) :: n real(kind=wp), dimension(n) :: x real(kind=wp), dimension(n) :: xl real(kind=wp), dimension(n) :: xu real(kind=wp) :: f real(kind=wp), dimension(la) :: c real(kind=wp), dimension(n+1) :: g real(kind=wp), dimension(la,n+1) :: a real(kind=wp) :: acc integer, intent(inout) :: iter in: maximum number of iterations. out: actual number of iterations. integer, intent(inout) :: mode real(kind=wp), dimension(m+n+n+2) :: r real(kind=wp), dimension((n+1)*(n+2)/2) :: l real(kind=wp), dimension(n) :: x0 real(kind=wp), dimension(la) :: mu real(kind=wp), dimension(n+1) :: s real(kind=wp), dimension(n+1) :: u real(kind=wp), dimension(n+1) :: v real(kind=wp), intent(inout), dimension(*) :: w dim(w) = integer, intent(inout), dimension(*) :: iw real(kind=wp), intent(inout) :: t real(kind=wp), intent(inout) :: f0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(inout) :: h2 real(kind=wp), intent(inout) :: h3 real(kind=wp), intent(inout) :: h4 integer, intent(inout) :: n1 integer, intent(inout) :: n2 integer, intent(inout) :: n3 real(kind=wp), intent(inout) :: t0 real(kind=wp), intent(inout) :: gs real(kind=wp), intent(inout) :: tol integer, intent(inout) :: line real(kind=wp), intent(inout) :: alpha integer, intent(inout) :: iexact integer, intent(inout) :: incons integer, intent(inout) :: ireset integer, intent(inout) :: itermx type( linmin_data ), intent(inout) :: ldat data for linmin . real(kind=wp), intent(in) :: alphamin min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real(kind=wp), intent(in) :: alphamax max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  private subroutine lsq (m, meq, n, nl, la, l, g, a, b, xl, xu, x, y, w, jw, mode) Minimize  || e x - f ||  with respect to x,\n  with upper triangular matrix  e = + d &#94;{1/2} l&#94;T ,\n  and vector  f = -d&#94;{-1/2} l&#94;{-1} g ,\n  where the unit lower tridiangular matrix l is stored columnwise\n  dense in the n*(n+1)/2 array l with vector d stored in its\n  'diagonal' thus substituting the one-elements of l Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: meq integer, intent(in) :: n integer, intent(in) :: nl integer, intent(in) :: la real(kind=wp), dimension(nl) :: l real(kind=wp), dimension(n) :: g real(kind=wp), dimension(la,n) :: a real(kind=wp), dimension(la) :: b real(kind=wp), dimension(n) :: xl real(kind=wp), dimension(n) :: xu real(kind=wp), dimension(n) :: x stores the n-dimensional solution vector real(kind=wp), dimension(m+n+n) :: y stores the vector of lagrange multipliers of dimension\n m+n+n (constraints+lower+upper bounds) real(kind=wp), dimension(*) :: w integer, dimension(*) :: jw integer :: mode is a success-failure flag with the following meanings: private subroutine lsei (c, d, e, f, g, h, lc, mc, le, me, lg, mg, n, x, xnrm, w, jw, mode) for mode=1 , the subroutine returns the solution x of\n  equality & inequality constrained least squares problem lsei : Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(lc,n) :: c real(kind=wp), intent(inout), dimension(lc) :: d real(kind=wp), intent(inout), dimension(le,n) :: e real(kind=wp), intent(inout), dimension(le) :: f real(kind=wp), intent(inout), dimension(lg,n) :: g real(kind=wp), intent(inout), dimension(lg) :: h integer, intent(in) :: lc integer, intent(in) :: mc integer, intent(in) :: le integer, intent(in) :: me integer, intent(in) :: lg integer, intent(in) :: mg integer, intent(in) :: n real(kind=wp), intent(out), dimension(n) :: x stores the solution vector real(kind=wp), intent(out) :: xnrm stores the residuum of the solution in euclidian norm real(kind=wp), intent(inout), dimension(*) :: w on return, stores the vector of lagrange multipliers\n in its first mc+mg elements integer, intent(inout), dimension(*) :: jw integer, intent(out) :: mode is a success-failure flag with the following meanings: private subroutine lsi (e, f, g, h, le, me, lg, mg, n, x, xnorm, w, jw, mode) for mode=1 , the subroutine returns the solution x of\n  inequality constrained linear least squares problem: Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(le,n) :: e real(kind=wp), intent(inout), dimension(le) :: f real(kind=wp), intent(inout), dimension(lg,n) :: g real(kind=wp), intent(inout), dimension(lg) :: h integer, intent(in) :: le integer, intent(in) :: me integer, intent(in) :: lg integer, intent(in) :: mg integer, intent(in) :: n real(kind=wp), intent(out), dimension(n) :: x stores the solution vector real(kind=wp), intent(out) :: xnorm stores the residuum of the solution in euclidian norm real(kind=wp), intent(inout), dimension(*) :: w stores the vector of lagrange multipliers in its first mg elements integer, intent(inout), dimension(lg) :: jw integer, intent(out) :: mode is a success-failure flag with the following meanings: private subroutine ldp (g, mg, m, n, h, x, xnorm, w, index, mode) Least distance programming routine.\n  Minimize  \\frac{1}{2} \\mathbf{x}&#94;T \\mathbf{x}   subject to\n   \\mathbf{G} \\mathbf{x} \\ge \\mathbf{h} . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(mg,n) :: g on entry g stores the m by n matrix of\n linear inequality constraints. g has first\n dimensioning parameter mg integer, intent(in) :: mg integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in), dimension(m) :: h the right side of the inequality system. real(kind=wp), intent(out), dimension(n) :: x solution vector x if mode=1 . real(kind=wp), intent(out) :: xnorm euclidian norm of the solution vector\n if computation is successful real(kind=wp), intent(inout), dimension(*) :: w w is a one dimensional working space, the length\n of which should be at least (m+2)*(n+1) + 2*m .\n on exit w stores the lagrange multipliers\n associated with the constraints.\n at the solution of problem ldp . integer, intent(inout), dimension(m) :: index integer working space integer, intent(out) :: mode success-failure flag with the following meanings: private subroutine nnls (a, mda, m, n, b, x, rnorm, w, zz, index, mode) Nonnegative least squares algorithm. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a on entry, contains the m by n matrix, a . on exit, contains\n the product matrix, q*a , where q is an m by m orthogonal matrix generated implicitly by\n this subroutine. integer, intent(in) :: mda first dimensioning parameter for the array a . integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(m) :: b on entry, contains the m-vector b . on exit, contains q*b . real(kind=wp), intent(out), dimension(n) :: x the solution vector. real(kind=wp), intent(out) :: rnorm euclidean norm of the residual vector. real(kind=wp), intent(inout), dimension(n) :: w array of working space.  on exit w will contain\n the dual solution vector. w will satisfy w(i) = 0 for all i in set p and w(i) <= 0 for all i in set z . real(kind=wp), intent(inout), dimension(m) :: zz an m-array of working space. integer, intent(out), dimension(n) :: index an integer working array.\n on exit the contents of this array define the sets p and z as follows: integer, intent(out) :: mode this is a success-failure flag with the following meanings: private subroutine hfti (a, mda, m, n, b, mdb, nb, tau, krank, rnorm, h, g, ip) Rank-deficient least squares algorithm using\n  householder forward triangulation with column interchanges. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a the array a initially contains the  m \\times n  matrix \\mathbf{A}\n of the least squares problem  \\mathbf{A} \\mathbf{x} = \\mathbf{b} .\n either m >= n or m < n is permitted.\n there is no restriction on the rank of a .\n the matrix a will be modified by the subroutine. integer, intent(in) :: mda the first dimensioning parameter of matrix a (mda >= m). integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(mdb,nb) :: b if nb = 0 the subroutine will make no reference\n to the array b . if nb > 0 the array b must\n initially contain the m x nb matrix b of the\n the least squares problem ax = b and on return\n the array b will contain the n x nb solution x . integer, intent(in) :: mdb first dimensioning parameter of matrix b (mdb>=max(m,n)) integer, intent(in) :: nb real(kind=wp), intent(in) :: tau absolute tolerance parameter for pseudorank\n determination, provided by the user. integer, intent(out) :: krank pseudorank of a , set by the subroutine. real(kind=wp), intent(out), dimension(nb) :: rnorm on exit, rnorm(j) will contain the euclidian\n norm of the residual vector for the problem\n defined by the j-th column vector of the array b . real(kind=wp), intent(inout), dimension(n) :: h array of working space real(kind=wp), intent(inout), dimension(n) :: g array of working space integer, intent(inout), dimension(n) :: ip integer array of working space\n recording permutation indices of column vectors private subroutine h12 (mode, lpivot, l1, m, u, iue, up, c, ice, icv, ncv) Construction and/or application of a single\n  householder transformation  Q = I + u(u&#94;t)/b . Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode 1 or 2 -- selects algorithm h1 to construct and apply a\n householder transformation, or algorithm h2 to apply a\n previously constructed transformation. integer, intent(in) :: lpivot the index of the pivot element integer, intent(in) :: l1 if l1 <= m the transformation will be constructed to\n zero elements indexed from l1 through m .\n if l1 > m the subroutine does an identity transformation. integer, intent(in) :: m see li . real(kind=wp), intent(inout), dimension(iue,*) :: u on entry with mode = 1 , u contains the pivot\n vector. iue is the storage increment between elements.\n on exit when mode = 1 , u and up contain quantities\n defining the vector u of the householder transformation.\n on entry with mode = 2 , u and up should contain\n quantities previously computed with mode = 1 .  these will\n not be modified during the entry with mode = 2 . dimension[u(iue,m)] integer, intent(in) :: iue see u . real(kind=wp), intent(inout) :: up see u . real(kind=wp), intent(inout), dimension(*) :: c on entry with mode = 1 or 2 , c contains a matrix which\n will be regarded as a set of vectors to which the\n householder transformation is to be applied.\n on exit c contains the set of transformed vectors. integer, intent(in) :: ice storage increment between elements of vectors in c . integer, intent(in) :: icv storage increment between vectors in c . integer, intent(in) :: ncv number of vectors in c to be transformed. if ncv <= 0 no operations will be done on c . private subroutine g1 (a, b, c, s, sig) Compute orthogonal rotation matrix. Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s real(kind=wp) :: sig private subroutine ldl (n, a, z, sigma, w) LDL&#94;T - rank-one - update Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the coefficient matrix a real(kind=wp), intent(inout), dimension(*) :: a In: positive definite matrix of dimension n ;\n only the lower triangle is used and is stored column by\n column as one dimensional array of dimension n*(n+1)/2 . real(kind=wp), intent(inout), dimension(*) :: z vector of dimension n of updating elements. real(kind=wp), intent(in) :: sigma scalar factor by which the modifying dyade z z&#94;T is multiplied. real(kind=wp), intent(inout), dimension(*) :: w working array of dimension n (used only if  \\sigma \\lt 0  ). private subroutine enforce_bounds (x, xl, xu) enforce the bound constraints on x. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x optimization variable vector real(kind=wp), intent(in), dimension(:) :: xl lower bounds (must be same dimension as x ) real(kind=wp), intent(in), dimension(:) :: xu upper bounds (must be same dimension as x ) private subroutine destroy_slsqpb_data (me) Destructor for slsqpb_data type. Arguments Type Intent Optional Attributes Name class( slsqpb_data ), intent(out) :: me private subroutine destroy_linmin_data (me) Destructor for linmin_data type. Arguments Type Intent Optional Attributes Name class( linmin_data ), intent(out) :: me","tags":"","loc":"module/slsqp_core.html","title":"slsqp_core – slsqp"},{"text":"Uses: slsqp_module slsqp_kinds program~~slsqp_test_2~~UsesGraph program~slsqp_test_2 slsqp_test_2 module~slsqp_module slsqp_module module~slsqp_module->program~slsqp_test_2 module~slsqp_kinds slsqp_kinds module~slsqp_kinds->program~slsqp_test_2 module~slsqp_kinds->module~slsqp_module module~slsqp_support slsqp_support module~slsqp_kinds->module~slsqp_support module~slsqp_core slsqp_core module~slsqp_kinds->module~slsqp_core module~slsqp_support->module~slsqp_module module~slsqp_support->module~slsqp_core iso_fortran_env iso_fortran_env iso_fortran_env->module~slsqp_module iso_fortran_env->module~slsqp_kinds module~slsqp_core->module~slsqp_module var panprogramslsqp_test_2UsesGraph = svgPanZoom('#programslsqp_test_2UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Test for the slsqp_module . Variables n m meq max_iter xl xu acc linesearch_mode solver x istat status_ok iterations Subroutines test_func test_grad report_iteration Source Code slsqp_test_2 Variables Type Attributes Name Initial integer, parameter :: n = 3 number of optimization variables integer, parameter :: m = 2 total number of constraints integer, parameter :: meq = 1 number of equality constraints integer, parameter :: max_iter = 100 maximum number of allowed iterations real(kind=wp), parameter, dimension(n) :: xl = [-10.0_wp, -10.0_wp, -10.0_wp] lower bounds real(kind=wp), parameter, dimension(n) :: xu = [10.0_wp, 10.0_wp, 10.0_wp] upper bounds real(kind=wp), parameter :: acc = 1.0e-7_wp tolerance integer, parameter :: linesearch_mode = 1 use inexact linesearch. type( slsqp_solver ) :: solver instantiate an slsqp solver real(kind=wp), dimension(n) :: x optimization variable vector integer :: istat for solver status check logical :: status_ok for initialization status check integer :: iterations number of iterations by the solver Subroutines subroutine test_func (me, x, f, c) Compute the objective function and constraints Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out) :: f value of the objective function real(kind=wp), intent(out), dimension(:) :: c the constraint vector dimension(m) ,\n equality constraints (if any) first. subroutine test_grad (me, x, g, a) compute the gradients. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out), dimension(:) :: g objective function partials w.r.t x dimension(n) real(kind=wp), intent(out), dimension(:,:) :: a gradient matrix of constraints w.r.t. x dimension(m,n) subroutine report_iteration (me, iter, x, f, c) report an iteration (print to the console). Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: iter real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in) :: f real(kind=wp), intent(in), dimension(:) :: c Source Code program slsqp_test_2 use slsqp_module use slsqp_kinds implicit none integer , parameter :: n = 3 !! number of optimization variables integer , parameter :: m = 2 !! total number of constraints integer , parameter :: meq = 1 !! number of equality constraints integer , parameter :: max_iter = 100 !! maximum number of allowed iterations real ( wp ), dimension ( n ), parameter :: xl = [ - 1 0.0_wp , - 1 0.0_wp , - 1 0.0_wp ] !! lower bounds real ( wp ), dimension ( n ), parameter :: xu = [ 1 0.0_wp , 1 0.0_wp , 1 0.0_wp ] !! upper bounds real ( wp ), parameter :: acc = 1.0e-7_wp !! tolerance integer , parameter :: linesearch_mode = 1 !! use inexact linesearch. type ( slsqp_solver ) :: solver !! instantiate an slsqp solver real ( wp ), dimension ( n ) :: x !! optimization variable vector integer :: istat !! for solver status check logical :: status_ok !! for initialization status check integer :: iterations !! number of iterations by the solver x = [ 1.0_wp , 2.0_wp , 3.0_wp ] ! initial guess call solver % initialize ( n , m , meq , max_iter , acc , test_func , test_grad ,& xl , xu , linesearch_mode = linesearch_mode , status_ok = status_ok ,& report = report_iteration ,& alphamin = 0.1_wp , alphamax = 0.5_wp ) !to limit search steps if ( status_ok ) then call solver % optimize ( x , istat , iterations ) write ( * , * ) '' write ( * , * ) 'solution   :' , x write ( * , * ) 'istat      :' , istat write ( * , * ) 'iterations :' , iterations write ( * , * ) '' else error stop 'error calling slsqp.' end if ! Solution is: x = [1,1,1], f = 3 contains subroutine test_func ( me , x , f , c ) !!  Compute the objective function and constraints !! !!  Minimize: !! !!   *  f = x_1&#94;2 + x_2&#94;2 + x_3  !! !!  Subject to: !! !!   *  c_1 = x_1 x_2 - x_3 = 0  !!   *  c_2 = x_3 - 1 \\ge 0  implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( out ) :: f !! value of the objective function real ( wp ), dimension (:), intent ( out ) :: c !! the constraint vector `dimension(m)`, !! equality constraints (if any) first. f = x ( 1 ) ** 2 + x ( 2 ) ** 2 + x ( 3 ) !objective function c ( 1 ) = x ( 1 ) * x ( 2 ) - x ( 3 ) !equality constraint (==0) c ( 2 ) = x ( 3 ) - 1.0_wp !inequality constraint (>=0) end subroutine test_func subroutine test_grad ( me , x , g , a ) !! compute the gradients. implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( out ) :: g !! objective function partials w.r.t x `dimension(n)` real ( wp ), dimension (:,:), intent ( out ) :: a !! gradient matrix of constraints w.r.t. x `dimension(m,n)` g ( 1 ) = 2.0_wp * x ( 1 ) g ( 2 ) = 2.0_wp * x ( 2 ) g ( 3 ) = 1.0_wp a ( 1 , 1 ) = x ( 2 ) a ( 1 , 2 ) = x ( 1 ) a ( 1 , 3 ) = - 1.0_wp a ( 2 , 1 ) = 0.0_wp a ( 2 , 2 ) = 0.0_wp a ( 2 , 3 ) = 1.0_wp end subroutine test_grad subroutine report_iteration ( me , iter , x , f , c ) !! report an iteration (print to the console). use , intrinsic :: iso_fortran_env , only : output_unit implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: iter real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), intent ( in ) :: f real ( wp ), dimension (:), intent ( in ) :: c !write a header: if ( iter == 0 ) then write ( output_unit , '(*(A20,1X))' ) 'iteration' , & 'x(1)' , 'x(2)' , 'x(3)' , & 'f(1)' , 'c(1)' , 'c(2)' end if !write the iteration data: write ( output_unit , '(I20,1X,(*(F20.16,1X)))' ) iter , x , f , c end subroutine report_iteration end program slsqp_test_2","tags":"","loc":"program/slsqp_test_2.html","title":"slsqp_test_2 – slsqp"},{"text":"Uses: slsqp_module slsqp_kinds program~~slsqp_test~~UsesGraph program~slsqp_test slsqp_test module~slsqp_module slsqp_module module~slsqp_module->program~slsqp_test module~slsqp_kinds slsqp_kinds module~slsqp_kinds->program~slsqp_test module~slsqp_kinds->module~slsqp_module module~slsqp_support slsqp_support module~slsqp_kinds->module~slsqp_support module~slsqp_core slsqp_core module~slsqp_kinds->module~slsqp_core module~slsqp_support->module~slsqp_module module~slsqp_support->module~slsqp_core iso_fortran_env iso_fortran_env iso_fortran_env->module~slsqp_module iso_fortran_env->module~slsqp_kinds module~slsqp_core->module~slsqp_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Test for the slsqp_module . Variables n m meq max_iter xl xu acc linesearch_mode solver x istat status_ok iterations Subroutines rosenbrock_func rosenbrock_grad report_iteration Source Code slsqp_test Variables Type Attributes Name Initial integer, parameter :: n = 2 number of optimization variables integer, parameter :: m = 1 total number of constraints integer, parameter :: meq = 0 number of equality constraints integer, parameter :: max_iter = 100 maximum number of allowed iterations real(kind=wp), parameter, dimension(n) :: xl = [-1.0_wp, -1.0_wp] lower bounds real(kind=wp), parameter, dimension(n) :: xu = [1.0_wp, 1.0_wp] upper bounds real(kind=wp), parameter :: acc = 1.0e-8_wp tolerance integer, parameter :: linesearch_mode = 1 use inexact linesearch. type( slsqp_solver ) :: solver instantiate an slsqp solver real(kind=wp), dimension(n) :: x optimization variable vector integer :: istat for solver status check logical :: status_ok for initialization status check integer :: iterations number of iterations by the solver Subroutines subroutine rosenbrock_func (me, x, f, c) Rosenbrock function Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out) :: f value of the objective function real(kind=wp), intent(out), dimension(:) :: c the constraint vector dimension(m) ,\n equality constraints (if any) first. subroutine rosenbrock_grad (me, x, g, a) gradients for rosenbrock_func . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out), dimension(:) :: g objective function partials w.r.t x dimension(n) real(kind=wp), intent(out), dimension(:,:) :: a gradient matrix of constraints w.r.t. x dimension(m,n) subroutine report_iteration (me, iter, x, f, c) report an iteration (print to the console). Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: iter real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in) :: f real(kind=wp), intent(in), dimension(:) :: c Source Code program slsqp_test use slsqp_module use slsqp_kinds implicit none integer , parameter :: n = 2 !! number of optimization variables integer , parameter :: m = 1 !! total number of constraints integer , parameter :: meq = 0 !! number of equality constraints integer , parameter :: max_iter = 100 !! maximum number of allowed iterations real ( wp ), dimension ( n ), parameter :: xl = [ - 1.0_wp , - 1.0_wp ] !! lower bounds real ( wp ), dimension ( n ), parameter :: xu = [ 1.0_wp , 1.0_wp ] !! upper bounds real ( wp ), parameter :: acc = 1.0e-8_wp !! tolerance integer , parameter :: linesearch_mode = 1 !! use inexact linesearch. type ( slsqp_solver ) :: solver !! instantiate an slsqp solver real ( wp ), dimension ( n ) :: x !! optimization variable vector integer :: istat !! for solver status check logical :: status_ok !! for initialization status check integer :: iterations !! number of iterations by the solver x = [ 0.1_wp , 0.1_wp ] !initial guess call solver % initialize ( n , m , meq , max_iter , acc , rosenbrock_func , rosenbrock_grad ,& xl , xu , linesearch_mode = linesearch_mode , status_ok = status_ok ,& report = report_iteration ) !alphamin=0.1_wp, alphamax=0.5_wp) !to limit search steps if ( status_ok ) then call solver % optimize ( x , istat , iterations ) write ( * , * ) '' write ( * , * ) 'solution   :' , x write ( * , * ) 'istat      :' , istat write ( * , * ) 'iterations :' , iterations write ( * , * ) '' else error stop 'error calling slsqp.' end if !solution:  x1 = 0.78641515097183889 !           x2 = 0.61769831659541152 !           f  = 4.5674808719160388E-002 !           c  = 2.8654301154062978E-012 contains subroutine rosenbrock_func ( me , x , f , c ) !! Rosenbrock function !! !! Minimize the Rosenbrock function:  f(x) = 100 (x_2 - x_1)&#94;2 + (1 - x_1)&#94;2 , !! subject to the inequality constraint:  x_1&#94;2 + x_2&#94;2 \\le 1 . !! !! see: http://www.mathworks.com/help/optim/ug/example-nonlinear-constrained-minimization.html implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( out ) :: f !! value of the objective function real ( wp ), dimension (:), intent ( out ) :: c !! the constraint vector `dimension(m)`, !! equality constraints (if any) first. f = 10 0.0_wp * ( x ( 2 ) - x ( 1 ) ** 2 ) ** 2 + ( 1.0_wp - x ( 1 )) ** 2 !objective function c ( 1 ) = 1.0_wp - x ( 1 ) ** 2 - x ( 2 ) ** 2 !equality constraint (>=0) end subroutine rosenbrock_func subroutine rosenbrock_grad ( me , x , g , a ) !! gradients for [[rosenbrock_func]]. implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( out ) :: g !! objective function partials w.r.t x `dimension(n)` real ( wp ), dimension (:,:), intent ( out ) :: a !! gradient matrix of constraints w.r.t. x `dimension(m,n)` g ( 1 ) = - 40 0.0_wp * ( x ( 2 ) - x ( 1 ) ** 2 ) * x ( 1 ) - 2.0_wp * ( 1.0_wp - x ( 1 )) !df/x1 g ( 2 ) = 20 0.0_wp * ( x ( 2 ) - x ( 1 ) ** 2 ) !df/x2 a ( 1 , 1 ) = - 2.0_wp * x ( 1 ) ! dc/dx1 a ( 1 , 2 ) = - 2.0_wp * x ( 2 ) ! dc/dx2 end subroutine rosenbrock_grad subroutine report_iteration ( me , iter , x , f , c ) use , intrinsic :: iso_fortran_env , only : output_unit !! report an iteration (print to the console). implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: iter real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), intent ( in ) :: f real ( wp ), dimension (:), intent ( in ) :: c !write a header: if ( iter == 0 ) then write ( output_unit , '(*(A20,1X))' ) 'iteration' , 'x(1)' , 'x(2)' , 'f(1)' , 'c(1)' end if !write the iteration data: write ( output_unit , '(I20,1X,(*(F20.16,1X)))' ) iter , x , f , c end subroutine report_iteration end program slsqp_test","tags":"","loc":"program/slsqp_test.html","title":"slsqp_test – slsqp"}]}